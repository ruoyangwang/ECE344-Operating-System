Index: kern/main/menu.c
===================================================================
--- kern/main/menu.c	(revision 20)
+++ kern/main/menu.c	(working copy)
@@ -1,923 +1,924 @@
-/*
- * In-kernel menu and command dispatcher.
- */
-
-#include <types.h>
-#include <kern/errno.h>
-#include <kern/unistd.h>
-#include <kern/limits.h>
-#include <lib.h>
-#include <clock.h>
-#include <thread.h>
-#include <curthread.h>
-#include <syscall.h>
-#include <uio.h>
-#include <vfs.h>
-#include <sfs.h>
-#include <test.h>
-#include "opt-synchprobs.h"
-#include "opt-sfs.h"
-#include "opt-net.h"
-
-#define _PATH_SHELL "/bin/sh"
-
-#define MAXMENUARGS  16
-
-#define DB_LOCORE      0x001
-#define DB_SYSCALL     0x002
-#define DB_INTERRUPT   0x004
-#define DB_DEVICE      0x008
-#define DB_THREADS     0x010
-#define DB_VM          0x020
-#define DB_EXEC        0x040
-#define DB_VFS         0x080
-#define DB_SFS         0x100
-#define DB_NET         0x200
-#define DB_NETFS       0x400
-#define DB_KMALLOC     0x800
-
-int DB_LOCORE_BIT;
-int DB_SYSCALL_BIT;
-int DB_INTERRUPT_BIT;
-int DB_DEVICE_BIT;
-int DB_THREADS_BIT;
-int DB_VM_BIT;
-int DB_EXEC_BIT;
-int DB_VFS_BIT;
-int DB_SFS_BIT;
-int DB_NET_BIT;
-int DB_NETFS_BIT;
-int DB_KMALLOC_BIT;
-int the_hex;
-
-void
-getinterval(time_t s1, u_int32_t ns1, time_t s2, u_int32_t ns2,
-	    time_t *rs, u_int32_t *rns)
-{
-	if (ns2 < ns1) {
-		ns2 += 1000000000;
-		s2--;
-	}
-
-	*rns = ns2 - ns1;
-	*rs = s2 - s1;
-}
-
-////////////////////////////////////////////////////////////
-//
-// Command menu functions 
-
-/*
- * Function for a thread that runs an arbitrary userlevel program by
- * name.
- *
- * Note: this cannot pass arguments to the program. You may wish to 
- * change it so it can, because that will make testing much easier
- * in the future.
- *
- * It copies the program name because runprogram destroys the copy
- * it gets by passing it to vfs_open(). 
- */
-static
-void
-cmd_progthread(void *ptr, unsigned long nargs)
-{
-	char **args = ptr;
-	char progname[128];
-	int result;
-
-	assert(nargs >= 1);
-
-	if (nargs > 2) {
-		kprintf("Warning: argument passing from menu not supported\n");
-	}
-
-	/* Hope we fit. */
-	assert(strlen(args[0]) < sizeof(progname));
-
-	strcpy(progname, args[0]);
-
-	result = runprogram(progname);
-	if (result) {
-		kprintf("Running program %s failed: %s\n", args[0],
-			strerror(result));
-		return;
-	}
-
-	/* NOTREACHED: runprogram only returns on error. */
-}
-
-/*
- * Common code for cmd_prog and cmd_shell.
- *
- * Note that this does not wait for the subprogram to finish, but
- * returns immediately to the menu. This is usually not what you want,
- * so you should have it call your system-calls-assignment waitpid
- * code after forking.
- *
- * Also note that because the subprogram's thread uses the "args"
- * array and strings, until you do this a race condition exists
- * between that code and the menu input code.
- */
-static
-int
-common_prog(int nargs, char **args)
-{
-	int result;
-
-#if OPT_SYNCHPROBS
-	kprintf("Warning: this probably won't work with a "
-		"synchronization-problems kernel.\n");
-#endif
-
-	struct thread * newthread;
-	result = thread_fork(args[0] /* thread name */,
-			args /* thread arg */, nargs /* thread arg */,
-			cmd_progthread, &newthread);
-			
-	if (result) {
-		kprintf("thread_fork failed: %s\n", strerror(result));
-		return result;
-	}
-	int retval, a =0;
-
-	
-	int i = sys_waitpid(newthread->pid, &retval,0,&a); 
-	//kprintf(" returned\n");
-	return 0;
-}
-
-/*
- * Command for running an arbitrary userlevel program.
- */
-static
-int
-cmd_prog(int nargs, char **args)
-{
-	if (nargs < 2) {
-		kprintf("Usage: p program [arguments]\n");
-		return EINVAL;
-	}
-
-	/* drop the leading "p" */
-	args++;
-	nargs--;
-
-	return common_prog(nargs, args);
-}
-
-/*
- * Command for starting the system shell.
- */
-static
-int
-cmd_shell(int nargs, char **args)
-{
-	(void)args;
-	if (nargs != 1) {
-		kprintf("Usage: s\n");
-		return EINVAL;
-	}
-
-	args[0] = (char *)_PATH_SHELL;
-
-	return common_prog(nargs, args);
-}
-
-/*
- * Command for changing directory.
- */
-static
-int
-cmd_chdir(int nargs, char **args)
-{
-	if (nargs != 2) {
-		kprintf("Usage: cd directory\n");
-		return EINVAL;
-	}
-
-	return vfs_chdir(args[1]);
-}
-
-/*
- * Command for printing the current directory.
- */
-static
-int
-cmd_pwd(int nargs, char **args)
-{
-	char buf[PATH_MAX+1];
-	struct uio ku;
-	int result;
-
-	(void)nargs;
-	(void)args;
-
-	mk_kuio(&ku, buf, sizeof(buf)-1, 0, UIO_READ);
-	result = vfs_getcwd(&ku);
-	if (result) {
-		kprintf("vfs_getcwd failed (%s)\n", strerror(result));
-		return result;
-	}
-
-	/* null terminate */
-	buf[sizeof(buf)-1-ku.uio_resid] = 0;
-
-	/* print it */
-	kprintf("%s\n", buf);
-
-	return 0;
-}
-
-/*
- * Command for running sync.
- */
-static
-int
-cmd_sync(int nargs, char **args)
-{
-	(void)nargs;
-	(void)args;
-
-	vfs_sync();
-
-	return 0;
-}
-
-/*
- * Command for doing an intentional panic.
- */
-static
-int
-cmd_panic(int nargs, char **args)
-{
-	(void)nargs;
-	(void)args;
-
-	panic("User requested panic\n");
-	return 0;
-}
-
-/*
- * Command for shutting down.
- */
-static
-int
-cmd_quit(int nargs, char **args)
-{
-	(void)nargs;
-	(void)args;
-
-	vfs_sync();
-	sys_reboot(RB_POWEROFF);
-	thread_exit();
-	return 0;
-}
-
-/*
- * Command for mounting a filesystem.
- */
-
-/* Table of mountable filesystem types. */
-static const struct {
-	const char *name;
-	int (*func)(const char *device);
-} mounttable[] = {
-#if OPT_SFS
-	{ "sfs", sfs_mount },
-#endif
-	{ NULL, NULL }
-};
-
-static
-int
-cmd_mount(int nargs, char **args)
-{
-	char *fstype;
-	char *device;
-	int i;
-
-	if (nargs != 3) {
-		kprintf("Usage: mount fstype device:\n");
-		return EINVAL;
-	}
-
-	fstype = args[1];
-	device = args[2];
-
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
-
-	for (i=0; mounttable[i].name; i++) {
-		if (!strcmp(mounttable[i].name, fstype)) {
-			return mounttable[i].func(device);
-		}
-	}
-	kprintf("Unknown filesystem type %s\n", fstype);
-	return EINVAL;
-}
-
-
-
-
-static
-int
-cmd_unmount(int nargs, char **args)
-{
-	char *device;
-
-	if (nargs != 2) {
-		kprintf("Usage: unmount device:\n");
-		return EINVAL;
-	}
-
-	device = args[1];
-
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
-
-	return vfs_unmount(device);
-}
-
-/*
- * Command to set the "boot fs". 
- *
- * The boot filesystem is the one that pathnames like /bin/sh with
- * leading slashes refer to.
- *
- * The default bootfs is "emu0".
- */
-static
-int
-cmd_bootfs(int nargs, char **args)
-{
-	char *device;
-
-	if (nargs != 2) {
-		kprintf("Usage: bootfs device\n");
-		return EINVAL;
-	}
-
-	device = args[1];
-
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
-
-	return vfs_setbootfs(device);
-}
-
-static
-int
-cmd_kheapstats(int nargs, char **args)
-{
-	(void)nargs;
-	(void)args;
-
-	kheap_printstats();
-	
-	return 0;
-}
-
-////////////////////////////////////////
-//
-// Menus.
-
-static
-void
-showmenu(const char *name, const char *x[])
-{
-	int ct, half, i;
-
-	kprintf("\n");
-	kprintf("%s\n", name);
-	
-	for (i=ct=0; x[i]; i++) {
-		ct++;
-	}
-	half = (ct+1)/2;
-
-	for (i=0; i<half; i++) {
-		kprintf("    %-36s", x[i]);
-		if (i+half < ct) {
-			kprintf("%s", x[i+half]);
-		}
-		kprintf("\n");
-	}
-
-	kprintf("\n");
-}
-static const char *dbflagmenu[] = {
-	"[df 1 on/off]       DB_LOCORE       ",
-	"[df 2 on/off]       DB_SYSCALL      ",
-	"[df 3 on/off]       DB_INTERRUPT    ",
-	"[df 4 on/off]       DB_DEVICE       ",
-	"[df 5 on/off]       DB_THREADS      ",
-	"[df 6 on/off]       DB_VM           ",
-	"[df 7 on/off]       DB_EXEC         ",
-	"[df 8 on/off]       DB_VFS          ",
-	"[df 9 on/off]       DB_SFS    	     ",
-	"[df 10 on/off]      DB_NET          ",
-	"[df 11 on/off]      DB_NETFS        ",
-	"[df 12 on/off]      DB_KMALLOC      ",
-	NULL
-};
-
-
-
-static const char *opsmenu[] = {
-	"[s]       Shell                     ",
-	"[p]       Other program             ",
-	"[dbflags] Debug flags",
-	"[mount]   Mount a filesystem        ",
-	"[unmount] Unmount a filesystem      ",
-	"[bootfs]  Set \"boot\" filesystem   ",
-	"[pf]      Print a file              ",
-	"[cd]      Change directory          ",
-  	"[pwd]     Print current directory   ",
-	"[sync]    Sync filesystems          ",
-	"[panic]   Intentional panic         ",
-	"[q]       Quit and shut down        ",
-	NULL
-};
-
-/*static const char *dbflagmenu[] = {
-	"  [df 1 on/off]        DB_LOCORE      [df 7 on/off]        DB_EXEC
-    [df 2 on/off]        DB_SYSCALL     [df 8 on/off]        DB_VFS
-    [df 3 on/off]        DB_INTERRUPT   [df 9 on/off]        DB_SFS
-    [df 4 on/off]        DB_DEVICE      [df 10 on/off]       DB_NET
-    [df 5 on/off]        DB_THREADS     [df 11 on/off]       DB_NETFS
-    [df 6 on/off]        DB_VM          [df 12 on/off]       DB_KMALLOC*/
-
-static
-int
-cmd_calbit(int nargs, char **args)
-{
-	int i;
-	i=atoi(args[1]);
-	if(nargs!=3||strcmp(args[0],"df")||i>12)
-	{
-		kprintf("Usage: df nr on/off\n");
-	}
-	if(i == 2)
-	{
-		if(!strcmp(args[2],"on") && DB_SYSCALL_BIT == 0)
-		{
-			the_hex += DB_SYSCALL;
-			DB_SYSCALL_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_SYSCALL_BIT == 1)
-		{
-			the_hex -= DB_SYSCALL;
-			DB_SYSCALL_BIT = 0;
-		}
-	}
-	else if(i == 1)
-	{
-		if(!strcmp(args[2],"on") && DB_LOCORE_BIT == 0)
-		{
-			the_hex += DB_LOCORE;
-			DB_LOCORE_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_LOCORE_BIT == 1)
-		{
-			the_hex -= DB_LOCORE;
-			DB_LOCORE_BIT = 0;
-		}
-	}
-	else if(i == 3)
-	{
-		if(!strcmp(args[2],"on") && DB_INTERRUPT_BIT == 0)
-		{
-			the_hex += DB_INTERRUPT;
-			DB_INTERRUPT_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_INTERRUPT_BIT == 1)
-		{
-			the_hex -= DB_INTERRUPT;
-			DB_INTERRUPT_BIT = 0;
-		}
-	}
-	else if(i == 4)
-	{
-		if(!strcmp(args[2],"on") && DB_DEVICE_BIT == 0)
-		{
-			the_hex += DB_DEVICE;
-			DB_DEVICE_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_DEVICE_BIT == 1)
-		{
-			the_hex -= DB_DEVICE;
-			DB_DEVICE_BIT = 0;
-		}
-	}
-	else if(i == 5)
-	{
-		if(!strcmp(args[2],"on") && DB_THREADS_BIT == 0)
-		{
-			the_hex += DB_THREADS;
-			DB_THREADS_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_THREADS_BIT == 1)
-		{
-			the_hex -= DB_THREADS;
-			DB_THREADS_BIT = 0;
-		}
-	}
-	else if(i == 6)
-	{
-		if(!strcmp(args[2],"on") && DB_VM_BIT == 0)
-		{
-			the_hex += DB_VM;
-			DB_VM_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_VM_BIT == 1)
-		{
-			the_hex -= DB_VM;
-			DB_VM_BIT = 0;
-		}
-	}
-	else if(i == 7)
-	{
-		if(!strcmp(args[2],"on") && DB_EXEC_BIT == 0)
-		{
-			the_hex += DB_EXEC;
-			DB_EXEC_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_EXEC_BIT == 1)
-		{
-			the_hex -= DB_EXEC;
-			DB_EXEC_BIT = 0;
-		}
-	}
-	else if(i == 8)
-	{
-		if(!strcmp(args[2],"on") && DB_VFS_BIT == 0)
-		{
-			the_hex += DB_VFS;
-			DB_VFS_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_VFS_BIT == 1)
-		{
-			the_hex -= DB_VFS;
-			DB_VFS_BIT = 0;
-		}
-	}
-	else if(i == 9)
-	{
-		if(!strcmp(args[2],"on") && DB_SFS_BIT == 0)
-		{
-			the_hex += DB_SFS;
-			DB_SFS_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_SFS_BIT == 1)
-		{
-			the_hex -= DB_SFS;
-			DB_SFS_BIT = 0;
-		}
-	}
-	else if(i == 10)
-	{
-		if(!strcmp(args[2],"on") && DB_NET_BIT == 0)
-		{
-			the_hex += DB_NET;
-			DB_NET_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_NET_BIT == 1)
-		{
-			the_hex -= DB_NET;
-			DB_NET_BIT = 0;
-		}
-	}
-	else if(i == 11)
-	{
-		if(!strcmp(args[2],"on") && DB_NETFS_BIT == 0)
-		{
-			the_hex += DB_NETFS;
-			DB_NETFS_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_NETFS_BIT == 1)
-		{
-			the_hex -= DB_NETFS;
-			DB_NETFS_BIT = 0;
-		}
-	}
-	else if(i == 12)
-	{
-		if(!strcmp(args[2],"on") && DB_KMALLOC_BIT == 0)
-		{
-			the_hex += DB_KMALLOC;
-			DB_KMALLOC_BIT = 1;
-		}
-		else if(!strcmp(args[2], "off") && DB_KMALLOC_BIT == 1)
-		{
-			the_hex -= DB_KMALLOC;
-			DB_KMALLOC_BIT = 0;
-		}
-	}
-	kprintf("Current value of dbflags is 0x%x\n", the_hex);
-	return 0;
-}
-
-static										// dbflag function
-int 																			
-cmd_dbflag(int nargs, char **args)
-{
-	(void) nargs;
-	(void) args;
-	/**int i;
-	i=atoi(args[3]);
-	if(nargs!=3||strcmp(args[1],"df")||i>12)
-	{
-		kprintf("Usage: df nr on/off\n");
-	}*/
-	
-	showmenu("OS/161 Debug flags", dbflagmenu);
-	kprintf("Current value of dbflags is 0x%x\n", the_hex);
-	
-	return 0;
-
-}
-
-
-static
-int
-cmd_opsmenu(int n, char **a)
-{
-	(void)n;
-	(void)a;
-
-	showmenu("OS/161 operations menu", opsmenu);
-	return 0;
-}
-
-static const char *testmenu[] = {
-	"[at]  Array test                    ",
-	"[bt]  Bitmap test                   ",
-	"[qt]  Queue test                    ",
-	"[km1] Kernel malloc test            ",
-	"[km2] kmalloc stress test           ",
-	"[tt1] Thread test 1                 ",
-	"[tt2] Thread test 2                 ",
-	"[tt3] Thread test 3                 ",
-#if OPT_NET
-	"[net] Network test                  ",
-#endif
-	"[sy1] Semaphore test                ",
-	"[sy2] Lock test             (1)     ",
-	"[sy3] CV test               (1)     ",
-	"[fs1] Filesystem test               ",
-	"[fs2] FS read stress        (4)     ",
-	"[fs3] FS write stress       (4)     ",
-	"[fs4] FS write stress 2     (4)     ",
-	"[fs5] FS create stress      (4)     ",
-	NULL
-};
-
-static
-int
-cmd_testmenu(int n, char **a)
-{
-	(void)n;
-	(void)a;
-
-	showmenu("OS/161 tests menu", testmenu);
-	kprintf("    (1) These tests will fail until you finish the "
-		"synch assignment.\n");
-	kprintf("    (4) These tests will fail until you finish the "
-		"file system assignment.\n");
-	kprintf("\n");
-
-	return 0;
-}
-
-static const char *mainmenu[] = {
-	"[?o] Operations menu                ",
-	"[?t] Tests menu                     ",
-#if OPT_SYNCHPROBS
-	"[1a] Cat/mouse with semaphores      ",
-	"[1b] Cat/mouse with locks and CVs   ",
-	"[1c] Stoplight                      ",
-#endif
-	"[kh] Kernel heap stats              ",
-	"[q] Quit and shut down              ",
-	NULL
-};
-
-static
-int
-cmd_mainmenu(int n, char **a)
-{
-	(void)n;
-	(void)a;
-
-	showmenu("OS/161 kernel menu", mainmenu);
-	return 0;
-}
-
-////////////////////////////////////////
-//
-// Command table.
-
-static struct {
-	const char *name;
-	int (*func)(int nargs, char **args);
-} cmdtable[] = {
-	/* menus */
-	{ "?",		cmd_mainmenu },
-	{ "h",		cmd_mainmenu },
-	{ "help",	cmd_mainmenu },
-	{ "?o",		cmd_opsmenu },
-	{ "?t",		cmd_testmenu },
-
-	/* operations */
-	{ "s",		cmd_shell },
-	{ "p",		cmd_prog },
-	{ "dbflags",	cmd_dbflag},		//add new dbflag interface
-	{ "mount",	cmd_mount },
-	{ "unmount",	cmd_unmount },
-	{ "bootfs",	cmd_bootfs },
-	{ "pf",		printfile },
-	{ "cd",		cmd_chdir },
-	{ "pwd",	cmd_pwd },
-	{ "sync",	cmd_sync },
-	{ "panic",	cmd_panic },
-	{ "q",		cmd_quit },
-	{ "exit",	cmd_quit },
-	{ "halt",	cmd_quit },
-	{ "df",		cmd_calbit },
-#if OPT_SYNCHPROBS
-	/* in-kernel synchronization problems */
-	{ "1a",		catmousesem },
-	{ "1b",		catmouselock },
-	{ "1c",		createcars },
-#endif
-
-	/* stats */
-	{ "kh",         cmd_kheapstats },
-
-	/* base system tests */
-	{ "at",		arraytest },
-	{ "bt",		bitmaptest },
-	{ "qt",		queuetest },
-	{ "km1",	malloctest },
-	{ "km2",	mallocstress },
-#if OPT_NET
-	{ "net",	nettest },
-#endif
-	{ "tt1",	threadtest },
-	{ "tt2",	threadtest2 },
-	{ "tt3",	threadtest3 },
-	{ "sy1",	semtest },
-
-	/* synchronization assignment tests */
-	{ "sy2",	locktest },
-	{ "sy3",	cvtest },
-
-	/* file system assignment tests */
-	{ "fs1",	fstest },
-	{ "fs2",	readstress },
-	{ "fs3",	writestress },
-	{ "fs4",	writestress2 },
-	{ "fs5",	createstress },
-
-	{ NULL, NULL }
-};
-
-/*
- * Process a single command.
- */
-static
-int
-cmd_dispatch(char *cmd)
-{
-	time_t beforesecs, aftersecs, secs;
-	u_int32_t beforensecs, afternsecs, nsecs;
-	char *args[MAXMENUARGS];
-	int nargs=0;
-	char *word;
-	char *context;
-	int i, result;
-
-	for (word = strtok_r(cmd, " \t", &context);
-	     word != NULL;
-	     word = strtok_r(NULL, " \t", &context)) {
-
-		if (nargs >= MAXMENUARGS) {
-			kprintf("Command line has too many words\n");
-			return E2BIG;
-		}
-		args[nargs++] = word;
-	}
-
-	if (nargs==0) {
-		return 0;
-	}
-
-	for (i=0; cmdtable[i].name; i++) {
-		if (*cmdtable[i].name && !strcmp(args[0], cmdtable[i].name)) {
-			assert(cmdtable[i].func!=NULL);
-
-			gettime(&beforesecs, &beforensecs);
-
-			result = cmdtable[i].func(nargs, args);
-
-			gettime(&aftersecs, &afternsecs);
-			getinterval(beforesecs, beforensecs,
-				    aftersecs, afternsecs,
-				    &secs, &nsecs);
-
-			kprintf("Operation took %lu.%09lu seconds\n",
-				(unsigned long) secs,
-				(unsigned long) nsecs);
-
-			return result;
-		}
-	}
-
-	kprintf("%s: Command not found\n", args[0]);
-	return EINVAL;
-}
-
-/*
- * Evaluate a command line that may contain multiple semicolon-delimited
- * commands.
- *
- * If "isargs" is set, we're doing command-line processing; print the
- * comamnds as we execute them and panic if the command is invalid or fails.
- */
-static
-void
-menu_execute(char *line, int isargs)
-{
-	char *command;
-	char *context;
-	int result;
-
-	for (command = strtok_r(line, ";", &context);
-	     command != NULL;
-	     command = strtok_r(NULL, ";", &context)) {
-
-		if (isargs) {
-			kprintf("OS/161 kernel: %s\n", command);
-		}
-
-		result = cmd_dispatch(command);
-		if (result) {
-			kprintf("Menu command failed: %s\n", strerror(result));
-			if (isargs) {
-				panic("Failure processing kernel arguments\n");
-			}
-		}
-	}
-}
-
-/*
- * Command menu main loop.
- *
- * First, handle arguments passed on the kernel's command line from
- * the bootloader. Then loop prompting for commands.
- *
- * The line passed in from the bootloader is treated as if it had been
- * typed at the prompt. Semicolons separate commands; spaces and tabs
- * separate words (command names and arguments).
- *
- * So, for instance, to mount an SFS on lhd0 and make it the boot
- * filesystem, and then boot directly into the shell, one would use
- * the kernel command line
- *
- *      "mount sfs lhd0; bootfs lhd0; s"
- */
-
-void
-menu(char *args)
-{
-	char buf[64];
-
-	DB_LOCORE_BIT = 0;
-	DB_SYSCALL_BIT = 0;
-	DB_INTERRUPT_BIT = 0;
-	DB_DEVICE_BIT = 0;
-	DB_THREADS_BIT = 0;
-	DB_VM_BIT = 0;
-	DB_EXEC_BIT = 0;
-	DB_VFS_BIT = 0;
-	DB_SFS_BIT = 0;
-	DB_NET_BIT = 0;
-	DB_NETFS_BIT = 0;
-	DB_KMALLOC_BIT = 0;
-	the_hex = 0x0;
-
-	menu_execute(args, 1);
-
-	while (1) {
-		kprintf("OS/161 kernel [? for menu]: ");
-		kgets(buf, sizeof(buf));
-		menu_execute(buf, 0);
-	}
-}
+/*
+ * In-kernel menu and command dispatcher.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <kern/limits.h>
+#include <lib.h>
+#include <clock.h>
+#include <thread.h>
+#include <syscall.h>
+#include <uio.h>
+#include <vfs.h>
+#include <sfs.h>
+#include <test.h>
+#include "opt-synchprobs.h"
+#include "opt-sfs.h"
+#include "opt-net.h"
+
+#define _PATH_SHELL "/bin/sh"
+
+#define MAXMENUARGS  16
+
+#define DB_LOCORE      0x001
+#define DB_SYSCALL     0x002
+#define DB_INTERRUPT   0x004
+#define DB_DEVICE      0x008
+#define DB_THREADS     0x010
+#define DB_VM          0x020
+#define DB_EXEC        0x040
+#define DB_VFS         0x080
+#define DB_SFS         0x100
+#define DB_NET         0x200
+#define DB_NETFS       0x400
+#define DB_KMALLOC     0x800
+
+int DB_LOCORE_BIT;
+int DB_SYSCALL_BIT;
+int DB_INTERRUPT_BIT;
+int DB_DEVICE_BIT;
+int DB_THREADS_BIT;
+int DB_VM_BIT;
+int DB_EXEC_BIT;
+int DB_VFS_BIT;
+int DB_SFS_BIT;
+int DB_NET_BIT;
+int DB_NETFS_BIT;
+int DB_KMALLOC_BIT;
+int the_hex;
+
+void
+getinterval(time_t s1, u_int32_t ns1, time_t s2, u_int32_t ns2,
+	    time_t *rs, u_int32_t *rns)
+{
+	if (ns2 < ns1) {
+		ns2 += 1000000000;
+		s2--;
+	}
+
+	*rns = ns2 - ns1;
+	*rs = s2 - s1;
+}
+
+////////////////////////////////////////////////////////////
+//
+// Command menu functions 
+
+/*
+ * Function for a thread that runs an arbitrary userlevel program by
+ * name.
+ *
+ * Note: this cannot pass arguments to the program. You may wish to 
+ * change it so it can, because that will make testing much easier
+ * in the future.
+ *
+ * It copies the program name because runprogram destroys the copy
+ * it gets by passing it to vfs_open(). 
+ */
+static
+void
+cmd_progthread(void *ptr, unsigned long nargs)
+{
+	char **args = ptr;
+	char progname[128];
+	int result;
+
+	assert(nargs >= 1);
+
+	if (nargs > 2) {
+		kprintf("Warning: argument passing from menu not supported\n");
+	}
+
+	/* Hope we fit. */
+	assert(strlen(args[0]) < sizeof(progname));
+
+	strcpy(progname, args[0]);
+
+	result = runprogram(progname);
+	if (result) {
+		kprintf("Running program %s failed: %s\n", args[0],
+			strerror(result));
+		return;
+	}
+
+	/* NOTREACHED: runprogram only returns on error. */
+}
+
+/*
+ * Common code for cmd_prog and cmd_shell.
+ *
+ * Note that this does not wait for the subprogram to finish, but
+ * returns immediately to the menu. This is usually not what you want,
+ * so you should have it call your system-calls-assignment waitpid
+ * code after forking.
+ *
+ * Also note that because the subprogram's thread uses the "args"
+ * array and strings, until you do this a race condition exists
+ * between that code and the menu input code.
+ */
+static
+int
+common_prog(int nargs, char **args)
+{
+	int result;
+    struct thread* newth;
+#if OPT_SYNCHPROBS
+	kprintf("Warning: this probably won't work with a "
+		"synchronization-problems kernel.\n");
+#endif
+
+	result = thread_fork(args[0] /* thread name */,
+			args /* thread arg */, nargs /* thread arg */,
+			cmd_progthread, &newth);
+			
+	if (result) {
+		kprintf("thread_fork failed: %s\n", strerror(result));
+		return result;
+	}
+	
+    lock_acquire(newth->lk);
+    while (newth->status == 0) {
+        cv_wait(newth->Waitonexit, newth->lk);
+    }
+    cv_signal(newth->Waittoexit, newth->lk);
+    lock_release(newth->lk);
+	/*while(numthreads!=1);*/
+	return 0;
+}
+
+/*
+ * Command for running an arbitrary userlevel program.
+ */
+static
+int
+cmd_prog(int nargs, char **args)
+{
+	if (nargs < 2) {
+		kprintf("Usage: p program [arguments]\n");
+		return EINVAL;
+	}
+
+	/* drop the leading "p" */
+	args++;
+	nargs--;
+
+	return common_prog(nargs, args);
+}
+
+/*
+ * Command for starting the system shell.
+ */
+static
+int
+cmd_shell(int nargs, char **args)
+{
+	(void)args;
+	if (nargs != 1) {
+		kprintf("Usage: s\n");
+		return EINVAL;
+	}
+
+	args[0] = (char *)_PATH_SHELL;
+
+	return common_prog(nargs, args);
+}
+
+/*
+ * Command for changing directory.
+ */
+static
+int
+cmd_chdir(int nargs, char **args)
+{
+	if (nargs != 2) {
+		kprintf("Usage: cd directory\n");
+		return EINVAL;
+	}
+
+	return vfs_chdir(args[1]);
+}
+
+/*
+ * Command for printing the current directory.
+ */
+static
+int
+cmd_pwd(int nargs, char **args)
+{
+	char buf[PATH_MAX+1];
+	struct uio ku;
+	int result;
+
+	(void)nargs;
+	(void)args;
+
+	mk_kuio(&ku, buf, sizeof(buf)-1, 0, UIO_READ);
+	result = vfs_getcwd(&ku);
+	if (result) {
+		kprintf("vfs_getcwd failed (%s)\n", strerror(result));
+		return result;
+	}
+
+	/* null terminate */
+	buf[sizeof(buf)-1-ku.uio_resid] = 0;
+
+	/* print it */
+	kprintf("%s\n", buf);
+
+	return 0;
+}
+
+/*
+ * Command for running sync.
+ */
+static
+int
+cmd_sync(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	vfs_sync();
+
+	return 0;
+}
+
+/*
+ * Command for doing an intentional panic.
+ */
+static
+int
+cmd_panic(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	panic("User requested panic\n");
+	return 0;
+}
+
+/*
+ * Command for shutting down.
+ */
+static
+int
+cmd_quit(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	vfs_sync();
+	sys_reboot(RB_POWEROFF);
+	thread_exit();
+	return 0;
+}
+
+/*
+ * Command for mounting a filesystem.
+ */
+
+/* Table of mountable filesystem types. */
+static const struct {
+	const char *name;
+	int (*func)(const char *device);
+} mounttable[] = {
+#if OPT_SFS
+	{ "sfs", sfs_mount },
+#endif
+	{ NULL, NULL }
+};
+
+static
+int
+cmd_mount(int nargs, char **args)
+{
+	char *fstype;
+	char *device;
+	int i;
+
+	if (nargs != 3) {
+		kprintf("Usage: mount fstype device:\n");
+		return EINVAL;
+	}
+
+	fstype = args[1];
+	device = args[2];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	for (i=0; mounttable[i].name; i++) {
+		if (!strcmp(mounttable[i].name, fstype)) {
+			return mounttable[i].func(device);
+		}
+	}
+	kprintf("Unknown filesystem type %s\n", fstype);
+	return EINVAL;
+}
+
+
+
+
+static
+int
+cmd_unmount(int nargs, char **args)
+{
+	char *device;
+
+	if (nargs != 2) {
+		kprintf("Usage: unmount device:\n");
+		return EINVAL;
+	}
+
+	device = args[1];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	return vfs_unmount(device);
+}
+
+/*
+ * Command to set the "boot fs". 
+ *
+ * The boot filesystem is the one that pathnames like /bin/sh with
+ * leading slashes refer to.
+ *
+ * The default bootfs is "emu0".
+ */
+static
+int
+cmd_bootfs(int nargs, char **args)
+{
+	char *device;
+
+	if (nargs != 2) {
+		kprintf("Usage: bootfs device\n");
+		return EINVAL;
+	}
+
+	device = args[1];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	return vfs_setbootfs(device);
+}
+
+static
+int
+cmd_kheapstats(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	kheap_printstats();
+	
+	return 0;
+}
+
+////////////////////////////////////////
+//
+// Menus.
+
+static
+void
+showmenu(const char *name, const char *x[])
+{
+	int ct, half, i;
+
+	kprintf("\n");
+	kprintf("%s\n", name);
+	
+	for (i=ct=0; x[i]; i++) {
+		ct++;
+	}
+	half = (ct+1)/2;
+
+	for (i=0; i<half; i++) {
+		kprintf("    %-36s", x[i]);
+		if (i+half < ct) {
+			kprintf("%s", x[i+half]);
+		}
+		kprintf("\n");
+	}
+
+	kprintf("\n");
+}
+static const char *dbflagmenu[] = {
+	"[df 1 on/off]       DB_LOCORE       ",
+	"[df 2 on/off]       DB_SYSCALL      ",
+	"[df 3 on/off]       DB_INTERRUPT    ",
+	"[df 4 on/off]       DB_DEVICE       ",
+	"[df 5 on/off]       DB_THREADS      ",
+	"[df 6 on/off]       DB_VM           ",
+	"[df 7 on/off]       DB_EXEC         ",
+	"[df 8 on/off]       DB_VFS          ",
+	"[df 9 on/off]       DB_SFS    	     ",
+	"[df 10 on/off]      DB_NET          ",
+	"[df 11 on/off]      DB_NETFS        ",
+	"[df 12 on/off]      DB_KMALLOC      ",
+	NULL
+};
+
+
+
+static const char *opsmenu[] = {
+	"[s]       Shell                     ",
+	"[p]       Other program             ",
+	"[dbflags] Debug flags",
+	"[mount]   Mount a filesystem        ",
+	"[unmount] Unmount a filesystem      ",
+	"[bootfs]  Set \"boot\" filesystem   ",
+	"[pf]      Print a file              ",
+	"[cd]      Change directory          ",
+  	"[pwd]     Print current directory   ",
+	"[sync]    Sync filesystems          ",
+	"[panic]   Intentional panic         ",
+	"[q]       Quit and shut down        ",
+	NULL
+};
+
+/*static const char *dbflagmenu[] = {
+	"  [df 1 on/off]        DB_LOCORE      [df 7 on/off]        DB_EXEC
+    [df 2 on/off]        DB_SYSCALL     [df 8 on/off]        DB_VFS
+    [df 3 on/off]        DB_INTERRUPT   [df 9 on/off]        DB_SFS
+    [df 4 on/off]        DB_DEVICE      [df 10 on/off]       DB_NET
+    [df 5 on/off]        DB_THREADS     [df 11 on/off]       DB_NETFS
+    [df 6 on/off]        DB_VM          [df 12 on/off]       DB_KMALLOC*/
+
+static
+int
+cmd_calbit(int nargs, char **args)
+{
+	int i;
+	i=atoi(args[1]);
+	if(nargs!=3||strcmp(args[0],"df")||i>12)
+	{
+		kprintf("Usage: df nr on/off\n");
+	}
+	if(i == 2)
+	{
+		if(!strcmp(args[2],"on") && DB_SYSCALL_BIT == 0)
+		{
+			the_hex += DB_SYSCALL;
+			DB_SYSCALL_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_SYSCALL_BIT == 1)
+		{
+			the_hex -= DB_SYSCALL;
+			DB_SYSCALL_BIT = 0;
+		}
+	}
+	else if(i == 1)
+	{
+		if(!strcmp(args[2],"on") && DB_LOCORE_BIT == 0)
+		{
+			the_hex += DB_LOCORE;
+			DB_LOCORE_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_LOCORE_BIT == 1)
+		{
+			the_hex -= DB_LOCORE;
+			DB_LOCORE_BIT = 0;
+		}
+	}
+	else if(i == 3)
+	{
+		if(!strcmp(args[2],"on") && DB_INTERRUPT_BIT == 0)
+		{
+			the_hex += DB_INTERRUPT;
+			DB_INTERRUPT_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_INTERRUPT_BIT == 1)
+		{
+			the_hex -= DB_INTERRUPT;
+			DB_INTERRUPT_BIT = 0;
+		}
+	}
+	else if(i == 4)
+	{
+		if(!strcmp(args[2],"on") && DB_DEVICE_BIT == 0)
+		{
+			the_hex += DB_DEVICE;
+			DB_DEVICE_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_DEVICE_BIT == 1)
+		{
+			the_hex -= DB_DEVICE;
+			DB_DEVICE_BIT = 0;
+		}
+	}
+	else if(i == 5)
+	{
+		if(!strcmp(args[2],"on") && DB_THREADS_BIT == 0)
+		{
+			the_hex += DB_THREADS;
+			DB_THREADS_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_THREADS_BIT == 1)
+		{
+			the_hex -= DB_THREADS;
+			DB_THREADS_BIT = 0;
+		}
+	}
+	else if(i == 6)
+	{
+		if(!strcmp(args[2],"on") && DB_VM_BIT == 0)
+		{
+			the_hex += DB_VM;
+			DB_VM_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_VM_BIT == 1)
+		{
+			the_hex -= DB_VM;
+			DB_VM_BIT = 0;
+		}
+	}
+	else if(i == 7)
+	{
+		if(!strcmp(args[2],"on") && DB_EXEC_BIT == 0)
+		{
+			the_hex += DB_EXEC;
+			DB_EXEC_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_EXEC_BIT == 1)
+		{
+			the_hex -= DB_EXEC;
+			DB_EXEC_BIT = 0;
+		}
+	}
+	else if(i == 8)
+	{
+		if(!strcmp(args[2],"on") && DB_VFS_BIT == 0)
+		{
+			the_hex += DB_VFS;
+			DB_VFS_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_VFS_BIT == 1)
+		{
+			the_hex -= DB_VFS;
+			DB_VFS_BIT = 0;
+		}
+	}
+	else if(i == 9)
+	{
+		if(!strcmp(args[2],"on") && DB_SFS_BIT == 0)
+		{
+			the_hex += DB_SFS;
+			DB_SFS_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_SFS_BIT == 1)
+		{
+			the_hex -= DB_SFS;
+			DB_SFS_BIT = 0;
+		}
+	}
+	else if(i == 10)
+	{
+		if(!strcmp(args[2],"on") && DB_NET_BIT == 0)
+		{
+			the_hex += DB_NET;
+			DB_NET_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_NET_BIT == 1)
+		{
+			the_hex -= DB_NET;
+			DB_NET_BIT = 0;
+		}
+	}
+	else if(i == 11)
+	{
+		if(!strcmp(args[2],"on") && DB_NETFS_BIT == 0)
+		{
+			the_hex += DB_NETFS;
+			DB_NETFS_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_NETFS_BIT == 1)
+		{
+			the_hex -= DB_NETFS;
+			DB_NETFS_BIT = 0;
+		}
+	}
+	else if(i == 12)
+	{
+		if(!strcmp(args[2],"on") && DB_KMALLOC_BIT == 0)
+		{
+			the_hex += DB_KMALLOC;
+			DB_KMALLOC_BIT = 1;
+		}
+		else if(!strcmp(args[2], "off") && DB_KMALLOC_BIT == 1)
+		{
+			the_hex -= DB_KMALLOC;
+			DB_KMALLOC_BIT = 0;
+		}
+	}
+	kprintf("Current value of dbflags is 0x%x\n", the_hex);
+	return 0;
+}
+
+static										// dbflag function
+int 																			
+cmd_dbflag(int nargs, char **args)
+{
+	(void) nargs;
+	(void) args;
+	/**int i;
+	i=atoi(args[3]);
+	if(nargs!=3||strcmp(args[1],"df")||i>12)
+	{
+		kprintf("Usage: df nr on/off\n");
+	}*/
+	
+	showmenu("OS/161 Debug flags", dbflagmenu);
+	kprintf("Current value of dbflags is 0x%x\n", the_hex);
+	
+	return 0;
+
+}
+
+
+static
+int
+cmd_opsmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 operations menu", opsmenu);
+	return 0;
+}
+
+static const char *testmenu[] = {
+	"[at]  Array test                    ",
+	"[bt]  Bitmap test                   ",
+	"[qt]  Queue test                    ",
+	"[km1] Kernel malloc test            ",
+	"[km2] kmalloc stress test           ",
+	"[tt1] Thread test 1                 ",
+	"[tt2] Thread test 2                 ",
+	"[tt3] Thread test 3                 ",
+#if OPT_NET
+	"[net] Network test                  ",
+#endif
+	"[sy1] Semaphore test                ",
+	"[sy2] Lock test             (1)     ",
+	"[sy3] CV test               (1)     ",
+	"[fs1] Filesystem test               ",
+	"[fs2] FS read stress        (4)     ",
+	"[fs3] FS write stress       (4)     ",
+	"[fs4] FS write stress 2     (4)     ",
+	"[fs5] FS create stress      (4)     ",
+	NULL
+};
+
+static
+int
+cmd_testmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 tests menu", testmenu);
+	kprintf("    (1) These tests will fail until you finish the "
+		"synch assignment.\n");
+	kprintf("    (4) These tests will fail until you finish the "
+		"file system assignment.\n");
+	kprintf("\n");
+
+	return 0;
+}
+
+static const char *mainmenu[] = {
+	"[?o] Operations menu                ",
+	"[?t] Tests menu                     ",
+#if OPT_SYNCHPROBS
+	"[1a] Cat/mouse with semaphores      ",
+	"[1b] Cat/mouse with locks and CVs   ",
+	"[1c] Stoplight                      ",
+#endif
+	"[kh] Kernel heap stats              ",
+	"[q] Quit and shut down              ",
+	NULL
+};
+
+static
+int
+cmd_mainmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 kernel menu", mainmenu);
+	return 0;
+}
+
+////////////////////////////////////////
+//
+// Command table.
+
+static struct {
+	const char *name;
+	int (*func)(int nargs, char **args);
+} cmdtable[] = {
+	/* menus */
+	{ "?",		cmd_mainmenu },
+	{ "h",		cmd_mainmenu },
+	{ "help",	cmd_mainmenu },
+	{ "?o",		cmd_opsmenu },
+	{ "?t",		cmd_testmenu },
+
+	/* operations */
+	{ "s",		cmd_shell },
+	{ "p",		cmd_prog },
+	{ "dbflags",	cmd_dbflag},		//add new dbflag interface
+	{ "mount",	cmd_mount },
+	{ "unmount",	cmd_unmount },
+	{ "bootfs",	cmd_bootfs },
+	{ "pf",		printfile },
+	{ "cd",		cmd_chdir },
+	{ "pwd",	cmd_pwd },
+	{ "sync",	cmd_sync },
+	{ "panic",	cmd_panic },
+	{ "q",		cmd_quit },
+	{ "exit",	cmd_quit },
+	{ "halt",	cmd_quit },
+	{ "df",		cmd_calbit },
+#if OPT_SYNCHPROBS
+	/* in-kernel synchronization problems */
+	{ "1a",		catmousesem },
+	{ "1b",		catmouselock },
+	{ "1c",		createcars },
+#endif
+
+	/* stats */
+	{ "kh",         cmd_kheapstats },
+
+	/* base system tests */
+	{ "at",		arraytest },
+	{ "bt",		bitmaptest },
+	{ "qt",		queuetest },
+	{ "km1",	malloctest },
+	{ "km2",	mallocstress },
+#if OPT_NET
+	{ "net",	nettest },
+#endif
+	{ "tt1",	threadtest },
+	{ "tt2",	threadtest2 },
+	{ "tt3",	threadtest3 },
+	{ "sy1",	semtest },
+
+	/* synchronization assignment tests */
+	{ "sy2",	locktest },
+	{ "sy3",	cvtest },
+
+	/* file system assignment tests */
+	{ "fs1",	fstest },
+	{ "fs2",	readstress },
+	{ "fs3",	writestress },
+	{ "fs4",	writestress2 },
+	{ "fs5",	createstress },
+
+	{ NULL, NULL }
+};
+
+/*
+ * Process a single command.
+ */
+static
+int
+cmd_dispatch(char *cmd)
+{
+	time_t beforesecs, aftersecs, secs;
+	u_int32_t beforensecs, afternsecs, nsecs;
+	char *args[MAXMENUARGS];
+	int nargs=0;
+	char *word;
+	char *context;
+	int i, result;
+
+	for (word = strtok_r(cmd, " \t", &context);
+	     word != NULL;
+	     word = strtok_r(NULL, " \t", &context)) {
+
+		if (nargs >= MAXMENUARGS) {
+			kprintf("Command line has too many words\n");
+			return E2BIG;
+		}
+		args[nargs++] = word;
+	}
+
+	if (nargs==0) {
+		return 0;
+	}
+
+	for (i=0; cmdtable[i].name; i++) {
+		if (*cmdtable[i].name && !strcmp(args[0], cmdtable[i].name)) {
+			assert(cmdtable[i].func!=NULL);
+
+			gettime(&beforesecs, &beforensecs);
+
+			result = cmdtable[i].func(nargs, args);
+
+			gettime(&aftersecs, &afternsecs);
+			getinterval(beforesecs, beforensecs,
+				    aftersecs, afternsecs,
+				    &secs, &nsecs);
+
+			kprintf("Operation took %lu.%09lu seconds\n",
+				(unsigned long) secs,
+				(unsigned long) nsecs);
+
+			return result;
+		}
+	}
+
+	kprintf("%s: Command not found\n", args[0]);
+	return EINVAL;
+}
+
+/*
+ * Evaluate a command line that may contain multiple semicolon-delimited
+ * commands.
+ *
+ * If "isargs" is set, we're doing command-line processing; print the
+ * comamnds as we execute them and panic if the command is invalid or fails.
+ */
+static
+void
+menu_execute(char *line, int isargs)
+{
+	char *command;
+	char *context;
+	int result;
+
+	for (command = strtok_r(line, ";", &context);
+	     command != NULL;
+	     command = strtok_r(NULL, ";", &context)) {
+
+		if (isargs) {
+			kprintf("OS/161 kernel: %s\n", command);
+		}
+
+		result = cmd_dispatch(command);
+		if (result) {
+			kprintf("Menu command failed: %s\n", strerror(result));
+			if (isargs) {
+				panic("Failure processing kernel arguments\n");
+			}
+		}
+	}
+}
+
+/*
+ * Command menu main loop.
+ *
+ * First, handle arguments passed on the kernel's command line from
+ * the bootloader. Then loop prompting for commands.
+ *
+ * The line passed in from the bootloader is treated as if it had been
+ * typed at the prompt. Semicolons separate commands; spaces and tabs
+ * separate words (command names and arguments).
+ *
+ * So, for instance, to mount an SFS on lhd0 and make it the boot
+ * filesystem, and then boot directly into the shell, one would use
+ * the kernel command line
+ *
+ *      "mount sfs lhd0; bootfs lhd0; s"
+ */
+
+void
+menu(char *args)
+{
+	char buf[64];
+
+	DB_LOCORE_BIT = 0;
+	DB_SYSCALL_BIT = 0;
+	DB_INTERRUPT_BIT = 0;
+	DB_DEVICE_BIT = 0;
+	DB_THREADS_BIT = 0;
+	DB_VM_BIT = 0;
+	DB_EXEC_BIT = 0;
+	DB_VFS_BIT = 0;
+	DB_SFS_BIT = 0;
+	DB_NET_BIT = 0;
+	DB_NETFS_BIT = 0;
+	DB_KMALLOC_BIT = 0;
+	the_hex = 0x0;
+
+	menu_execute(args, 1);
+
+	while (1) {
+		kprintf("OS/161 kernel [? for menu]: ");
+		kgets(buf, sizeof(buf));
+		menu_execute(buf, 0);
+	}
+}
Index: kern/thread/synch.c
===================================================================
--- kern/thread/synch.c	(revision 20)
+++ kern/thread/synch.c	(working copy)
@@ -56,7 +56,9 @@
 	 */
 
 	kfree(sem->name);
+	bzero(sem, sizeof(struct semaphore));
 	kfree(sem);
+	
 }
 
 void 
@@ -128,7 +130,9 @@
 	// add stuff here as needed
 	
 	kfree(lock->name);
+	bzero(lock, sizeof(struct lock));
 	kfree(lock);
+	
 }
 
 void
@@ -141,6 +145,7 @@
 	int interrupt;
 	//kprintf("ready to take the lock\n");
 	interrupt = splhigh();	
+	assert(lock_do_i_hold(lock)==0);
 	while(lock->own != NULL)		//SOMEONE IS HOLDING THE LOCK
 	{		
 		thread_sleep(lock);
@@ -175,12 +180,13 @@
 {
 	// Write this
   	   // suppress warning until code gets written
+  	int spl, ret; 
+  	
+  	spl =  splhigh();	
 	assert(lock!=NULL);
-	if(lock->own == curthread)
-       		return 1;  // dummy until code gets written
-	else 
-		return 0;
-	//return 1;	
+	ret = lock->own == curthread;
+	splx(spl);
+	return ret;
 	
 }
 
@@ -218,7 +224,9 @@
 	// add stuff here as needed
 	
 	kfree(cv->name);
+	bzero(cv, sizeof(struct cv));
 	kfree(cv);
+	
 }
 
 void
@@ -231,6 +239,7 @@
     assert(cv != NULL);
     assert(lock != NULL);
 	
+	assert(lock_do_i_hold(lock));
 	lock_release(lock);
 	
 
@@ -238,7 +247,7 @@
 
 	
 	
-		thread_sleep(cv);
+	thread_sleep(cv);
 	
 	//cv->sleep=cv->sleep-1;
 	//cv->wakeup=cv->wakeup-1;
Index: kern/thread/thread.c
===================================================================
--- kern/thread/thread.c	(revision 20)
+++ kern/thread/thread.c	(working copy)
@@ -1,747 +1,717 @@
-/*
- * Core thread system.
- */
-#include <types.h>
-#include <lib.h>
-#include <kern/errno.h>
-#include <array.h>
-#include <machine/spl.h>
-#include <machine/pcb.h>
-#include <thread.h>
-#include <synch.h>
-#include <curthread.h>
-#include <scheduler.h>
-#include <addrspace.h>
-#include <vnode.h>
-#include "opt-synchprobs.h"
-
-/* States a thread can be in. */
-typedef enum {
-	S_RUN,
-	S_READY,
-	S_SLEEP,
-	S_ZOMB,
-} threadstate_t;
-
-/*struct link_list
-{
-	struct link_list *next;
-	int pid_value;
-};*/
-
-//int pid_array[1000];
-//int arraycount;
-int pid_assign;
-
-
-
-/* Global variable for the thread currently executing at any given time. */
-struct thread *curthread;
-//struct lock *t_lock;
-
-/* Table of sleeping threads. */
-static struct array *sleepers;
-
-/* List of dead threads to be disposed of. */
-static struct array *zombies;
-
-/* Total number of outstanding threads. Does not count zombies[]. */
-static int numthreads;
-
-/*
- * Create a thread. This is used both to create the first thread's 
- * thread structure and to create subsequent threads.
- */
-//
-
-static
-struct thread *
-thread_create(const char *name)
-{
-	struct thread *thread = kmalloc(sizeof(struct thread));
-	if (thread==NULL) {
-		return NULL;
-	}
-	thread->t_name = kstrdup(name);
-	if (thread->t_name==NULL) {
-		kfree(thread);
-		return NULL;
-	}
-	thread->t_sleepaddr = NULL;
-	thread->t_stack = NULL;
-	
-	thread->t_vmspace = NULL;
-
-	thread->t_cwd = NULL;
-	
-	
-	//thread->info.status = 100; // -1 means not in use; otherwise it will be equal to the exitcode.
-	//thread-> threadlock = lock_create("threadlock");
-	thread->lk =lock_create("lock");
-	thread-> Waitonexit = cv_create("onexit");
-	thread-> Waittoexit = cv_create("toexit");
-	thread->exitcode = 100;
-	thread->status = 0;
-	thread->pid = -1;
-	thread->waiting_child = 0;// 0=neither waiting or exiting; 1=waiting; 2=exiting.
-	thread->waiting_parent = 0;
-    thread->parent = curthread;
-    bzero(thread->child, sizeof (thread->child));
-	// If you add things to the thread structure, be sure to initialize
-	// them here.
-	//thread->pid = (int*)q_remhead(process_ids);	//initialize the process pid
-	int interrupt = splhigh();
-	
-	/*if(arraycount > 1)		//if the array still holds some pid that is available to use 
-	{
-		thread->info.pid = pid_array[arraycount]; 
-		arraycount--;
-	}
-	else
-	{
-		if( pid_assign >20)
-			return EAGAIN;
-		else{
-			thread->info.pid = pid_assign;
-			pid_assign++;
-		}
-	}*/
-	//lock_acquire(t_lock);
-	
-		thread->pid = pid_assign;
-		pid_assign++;
-	
-	//lock_release(t_lock);
-	splx(interrupt);
-	
-	return thread;
-}
-
-/*
- * Destroy a thread.
- *
- * This function cannot be called in the victim thread's own context.
- * Freeing the stack you're actually using to run would be... inadvisable.
- */
-static
-void
-thread_destroy(struct thread *thread)
-{
-	assert(thread != curthread);
-	//lock_destroy(t_lock);
-
-	// If you add things to the thread structure, be sure to dispose of
-	// them here or in thread_exit.
-	/*int interrupt = splhigh();			//reclaim back the pid and store into a static array
-	arraycount++;
-	pid_array[arraycount] = thread->info.pid;
-	thread->info.pid= -1;				//set the thread pid to initial value
-	//kfree(thread->pid);
-
-	splx(interrupt);*/
-
-	// These things are cleaned up in thread_exit.
-	assert(thread->t_vmspace==NULL);
-	assert(thread->t_cwd==NULL);
-	
-	if (thread->t_stack) {
-		kfree(thread->t_stack);
-	}
-
-	kfree(thread->t_name);
-    	cv_destroy(curthread->Waitonexit);
-//    curthread->Waitonexit = NULL;
-	cv_destroy(curthread->Waittoexit);
-//    curthread->Waittoexit = NULL;
-    	lock_destroy(curthread->lk);
-//    curthread->lk = NULL;
-	kfree(thread);
-}
-
-
-/*
- * Remove zombies. (Zombies are threads/processes that have exited but not
- * been fully deleted yet.)
- */
-static
-void
-exorcise(void)
-{
-	int i, result;
-
-	assert(curspl>0);
-	
-	for (i=0; i<array_getnum(zombies); i++) {
-		struct thread *z = array_getguy(zombies, i);
-		assert(z!=curthread);
-		thread_destroy(z);
-	}
-	result = array_setsize(zombies, 0);
-	/* Shrinking the array; not supposed to be able to fail. */
-	assert(result==0);
-}
-
-/*
- * Kill all sleeping threads. This is used during panic shutdown to make 
- * sure they don't wake up again and interfere with the panic.
- */
-static
-void
-thread_killall(void)
-{
-	int i, result;
-
-	assert(curspl>0);
-
-	/*
-	 * Move all sleepers to the zombie list, to be sure they don't
-	 * wake up while we're shutting down.
-	 */
-
-	for (i=0; i<array_getnum(sleepers); i++) {
-		struct thread *t = array_getguy(sleepers, i);
-		kprintf("sleep: Dropping thread %s\n", t->t_name);
-
-		/*
-		 * Don't do this: because these threads haven't
-		 * been through thread_exit, thread_destroy will
-		 * get upset. Just drop the threads on the floor,
-		 * which is safer anyway during panic.
-		 *
-		 * array_add(zombies, t);
-		 */
-	}
-
-	result = array_setsize(sleepers, 0);
-	/* shrinking array: not supposed to fail */
-	assert(result==0);
-}
-
-/*
- * Shut down the other threads in the thread system when a panic occurs.
- */
-void
-thread_panic(void)
-{
-	assert(curspl > 0);
-
-	thread_killall();
-	scheduler_killall();
-}
-
-/*
- * Thread initialization.
- */
-struct thread *
-thread_bootstrap(void)
-{
-	struct thread *me;
-
-	/* Create the data structures we need. */
-	sleepers = array_create();
-	if (sleepers==NULL) {
-		panic("Cannot create sleepers array\n");
-	}
-
-	zombies = array_create();
-	if (zombies==NULL) {
-		panic("Cannot create zombies array\n");
-	}
-	
-	/*
-	 * Create the thread structure for the first thread
-	 * (the one that's already running)
-	 */
-	me = thread_create("<boot/menu>");
-	if (me==NULL) {
-		panic("thread_bootstrap: Out of memory\n");
-	}
-
-	/*
-	 * Leave me->t_stack NULL. This means we're using the boot stack,
-	 * which can't be freed.
-	 */
-
-	/* Initialize the first thread's pcb */
-	md_initpcb0(&me->t_pcb);
-
-	/* Set curthread */
-	curthread = me;
-
-	/* Number of threads starts at 1 */
-	numthreads = 1;
-
-	pid_assign = 0;				//initialize the global variables
-	
-	//arraycount=0;
-	//pid_h = NULL;
-	
-//	t_lock = lock_create("t_lock");
-//	p_wait = sem_create("p_wait", 1);
-//	p_exit = sem_create("p_exit", 1);
-	
-	/* Done */
-	return me;
-}
-
-/*
- * Thread final cleanup.
- */
-void
-thread_shutdown(void)
-{
-	array_destroy(sleepers);
-	sleepers = NULL;
-	array_destroy(zombies);
-	zombies = NULL;
-	// Don't do this - it frees our stack and we blow up
-	
-	//thread_destroy(curthread);
-}
-
-/*
- * Create a new thread based on an existing one.
- * The new thread has name NAME, and starts executing in function FUNC.
- * DATA1 and DATA2 are passed to FUNC.
- */
-int
-thread_fork(const char *name, 
-	    void *data1, unsigned long data2,
-	    void (*func)(void *, unsigned long),
-	    struct thread **ret)
-{
-	struct thread *newguy;
-	int s, result;
-
-	/* Allocate a thread */
-	newguy = thread_create(name);
-	if (newguy==NULL) {
-		return ENOMEM;
-	}
-
-	/* Allocate a stack */
-	newguy->t_stack = kmalloc(STACK_SIZE);
-	if (newguy->t_stack==NULL) {
-		kfree(newguy->t_name);
-		kfree(newguy);
-		return ENOMEM;
-	}
-
-	/* stick a magic number on the bottom end of the stack */
-	newguy->t_stack[0] = 0xae;
-	newguy->t_stack[1] = 0x11;
-	newguy->t_stack[2] = 0xda;
-	newguy->t_stack[3] = 0x33;
-
-	/* Inherit the current directory */
-	if (curthread->t_cwd != NULL) {
-		VOP_INCREF(curthread->t_cwd);
-		newguy->t_cwd = curthread->t_cwd;
-	}
-
-	/* Set up the pcb (this arranges for func to be called) */
-	md_initpcb(&newguy->t_pcb, newguy->t_stack, data1, data2, func);
-
-	/* Interrupts off for atomicity */
-	s = splhigh();
-
-	/*
-	 * Make sure our data structures have enough space, so we won't
-	 * run out later at an inconvenient time.
-	 */
-	result = array_preallocate(sleepers, numthreads+1);
-	if (result) {
-		goto fail;
-	}
-	result = array_preallocate(zombies, numthreads+1);
-	if (result) {
-		goto fail;
-	}
-
-	/* Do the same for the scheduler. */
-	result = scheduler_preallocate(numthreads+1);
-	if (result) {
-		goto fail;
-	}
-
-	/* Make the new thread runnable */
-	result = make_runnable(newguy);
-	if (result != 0) {
-		goto fail;
-	}
-
-	/*
-	 * Increment the thread counter. This must be done atomically
-	 * with the preallocate calls; otherwise the count can be
-	 * temporarily too low, which would obviate its reason for
-	 * existence.
-	 */
-	numthreads++;
-	
-	newguy->parent = curthread;
-	int i =0;
-	for(i =0;i<20;i++)
-	{
-		if(curthread->child[i]==NULL)
-		{
-			curthread->child[i]=newguy;
-			break;
-		}
-	}
-	
-									//NOW DONE WITH FORK
-	
-		// Here build a linked list for pid and exit status of threads.
-		
-	
-	/*struct pid_linklist *new_node;
-	new_node = kmalloc(sizeof(struct pid_linklist));
-	new_node->next = NULL;
-	new_node->the_child = newguy;
-	new_node->the_parent = curthread;
-	new_node->checked = 0;
-	new_node->exitcode = 100;
-	new_node->waitcode = 0;
-	new_node->cv = cv_create("cv");
-	new_node->pstate = 0;	// state: 0 = initial condition
-	new_node->cstate = 0;	//state: 0 = initial condition
-	new_node->nodelock = lock_create("nodelock");
-	if(pid_h == NULL){
-		pid_h = new_node;
-	}
-	else{
-		struct pid_linklist *curr;
-		curr = pid_h;
-		while(curr->next != NULL)
-			curr = curr->next;
-		curr->next = new_node;
-	}*/
-
-	/* Done with stuff that needs to be atomic */
-	splx(s);
-
-	/*
-	 * Return new thread structure if it's wanted.  Note that
-	 * using the thread structure from the parent thread should be
-	 * done only with caution, because in general the child thread
-	 * might exit at any time.
-	 */
-	if (ret != NULL) {
-		*ret = newguy;
-	}
-
-	return 0;
-
- fail:
-	splx(s);
-	if (newguy->t_cwd != NULL) {
-		VOP_DECREF(newguy->t_cwd);
-	}
-	kfree(newguy->t_stack);
-	kfree(newguy->t_name);
-	kfree(newguy);
-
-	return result;
-}
-
-/*
- * High level, machine-independent context switch code.
- */
-static
-void
-mi_switch(threadstate_t nextstate)
-{
-	struct thread *cur, *next;
-	int result;
-	
-	/* Interrupts should already be off. */
-	assert(curspl>0);
-
-	if (curthread != NULL && curthread->t_stack != NULL) {
-		/*
-		 * Check the magic number we put on the bottom end of
-		 * the stack in thread_fork. If these assertions go
-		 * off, it most likely means you overflowed your stack
-		 * at some point, which can cause all kinds of
-		 * mysterious other things to happen.
-		 */
-		assert(curthread->t_stack[0] == (char)0xae);
-		assert(curthread->t_stack[1] == (char)0x11);
-		assert(curthread->t_stack[2] == (char)0xda);
-		assert(curthread->t_stack[3] == (char)0x33);
-	}
-	
-	/* 
-	 * We set curthread to NULL while the scheduler is running, to
-	 * make sure we don't call it recursively (this could happen
-	 * otherwise, if we get a timer interrupt in the idle loop.)
-	 */
-	if (curthread == NULL) {
-		return;
-	}
-	cur = curthread;
-	curthread = NULL;
-
-	/*
-	 * Stash the current thread on whatever list it's supposed to go on.
-	 * Because we preallocate during thread_fork, this should not fail.
-	 */
-
-	if (nextstate==S_READY) {
-		result = make_runnable(cur);
-	}
-	else if (nextstate==S_SLEEP) {
-		/*
-		 * Because we preallocate sleepers[] during thread_fork,
-		 * this should never fail.
-		 */
-		result = array_add(sleepers, cur);
-	}
-	else {
-		assert(nextstate==S_ZOMB);
-		result = array_add(zombies, cur);
-	}
-	assert(result==0);
-
-	/*
-	 * Call the scheduler (must come *after* the array_adds)
-	 */
-
-	next = scheduler();
-
-	/* update curthread */
-	curthread = next;
-	
-	/* 
-	 * Call the machine-dependent code that actually does the
-	 * context switch.
-	 */
-	md_switch(&cur->t_pcb, &next->t_pcb);
-	
-	/*
-	 * If we switch to a new thread, we don't come here, so anything
-	 * done here must be in mi_threadstart() as well, or be skippable,
-	 * or not apply to new threads.
-	 *
-	 * exorcise is skippable; as_activate is done in mi_threadstart.
-	 */
-
-	exorcise();
-
-	if (curthread->t_vmspace) {
-		as_activate(curthread->t_vmspace);
-	}
-}
-
-/*
- * Cause the current thread to exit.
- *
- * We clean up the parts of the thread structure we don't actually
- * need to run right away. The rest has to wait until thread_destroy
- * gets called from exorcise().
- */
-void
-thread_exit(void)
-{
-	
-	
-	
-	
-	if (curthread->t_stack != NULL) {
-		/*
-		 * Check the magic number we put on the bottom end of
-		 * the stack in thread_fork. If these assertions go
-		 * off, it most likely means you overflowed your stack
-		 * at some point, which can cause all kinds of
-		 * mysterious other things to happen.
-		 */
-		assert(curthread->t_stack[0] == (char)0xae);
-		assert(curthread->t_stack[1] == (char)0x11);
-		assert(curthread->t_stack[2] == (char)0xda);
-		assert(curthread->t_stack[3] == (char)0x33);
-	}
-
-	splhigh();
-	
-	
-
-	if (curthread->t_vmspace) {
-		/*
-		 * Do this carefully to avoid race condition with
-		 * context switch code.
-		 */
-		struct addrspace *as = curthread->t_vmspace;
-		curthread->t_vmspace = NULL;
-		as_destroy(as);
-	}
-
-	if (curthread->t_cwd) {
-		VOP_DECREF(curthread->t_cwd);
-		curthread->t_cwd = NULL;
-	}
-
-	assert(numthreads>0);
-	numthreads--;
-	mi_switch(S_ZOMB);
-
-	panic("Thread came back from the dead!\n");
-}
-
-/*
- * Yield the cpu to another process, but stay runnable.
- */
-void
-thread_yield(void)
-{
-	int spl = splhigh();
-
-	/* Check sleepers just in case we get here after shutdown */
-	assert(sleepers != NULL);
-
-	mi_switch(S_READY);
-	splx(spl);
-}
-
-/*
- * Yield the cpu to another process, and go to sleep, on "sleep
- * address" ADDR. Subsequent calls to thread_wakeup with the same
- * value of ADDR will make the thread runnable again. The address is
- * not interpreted. Typically it's the address of a synchronization
- * primitive or data structure.
- *
- * Note that (1) interrupts must be off (if they aren't, you can
- * end up sleeping forever), and (2) you cannot sleep in an 
- * interrupt handler.
- */
-void
-thread_sleep(const void *addr)
-{
-	// may not sleep in an interrupt handler
-	assert(in_interrupt==0);
-	
-	curthread->t_sleepaddr = addr;
-	mi_switch(S_SLEEP);
-	curthread->t_sleepaddr = NULL;
-}
-
-/*
- * Wake up one or more threads who are sleeping on "sleep address"
- * ADDR.
- */
-void
-thread_wakeup(const void *addr)
-{
-	int i, result;
-	
-	// meant to be called with interrupts off
-	assert(curspl>0);
-	
-	// This is inefficient. Feel free to improve it.
-	
-	for (i=0; i<array_getnum(sleepers); i++) {
-		struct thread *t = array_getguy(sleepers, i);
-		if (t->t_sleepaddr == addr) {
-			
-			// Remove from list
-			array_remove(sleepers, i);
-			
-			// must look at the same sleepers[i] again
-			i--;
-
-			/*
-			 * Because we preallocate during thread_fork,
-			 * this should never fail.
-			 */
-			result = make_runnable(t);
-			assert(result==0);
-						//BREAK THE LOOP, MAKE IT WAKE UP ONLY ONE GUY AT ONCE
-		}
-	}
-}
-
-void
-thread_wakeone(const void *addr)
-{
-	int i, result;
-	
-	// meant to be called with interrupts off
-	assert(curspl>0);
-	
-	// This is inefficient. Feel free to improve it.
-	
-	for (i=0; i<array_getnum(sleepers); i++) {
-		struct thread *t = array_getguy(sleepers, i);
-		if (t->t_sleepaddr == addr) {
-			
-			// Remove from list
-			array_remove(sleepers, i);
-			
-			// must look at the same sleepers[i] again
-			i--;
-
-			/*
-			 * Because we preallocate during thread_fork,
-			 * this should never fail.
-			 */
-			result = make_runnable(t);
-			assert(result==0);
-			break;		//BREAK THE LOOP, MAKE IT WAKE UP ONLY ONE GUY AT ONCE
-		}
-	}
-}
-
-/*
- * Return nonzero if there are any threads who are sleeping on "sleep address"
- * ADDR. This is meant to be used only for diagnostic purposes.
- */
-int
-thread_hassleepers(const void *addr)
-{
-	int i;
-	
-	// meant to be called with interrupts off
-	assert(curspl>0);
-	
-	for (i=0; i<array_getnum(sleepers); i++) {
-		struct thread *t = array_getguy(sleepers, i);
-		if (t->t_sleepaddr == addr) {
-			return 1;
-		}
-	}
-	return 0;
-}
-
-/*
- * New threads actually come through here on the way to the function
- * they're supposed to start in. This is so when that function exits,
- * thread_exit() can be called automatically.
- */
-void
-mi_threadstart(void *data1, unsigned long data2, 
-	       void (*func)(void *, unsigned long))
-{
-	/* If we have an address space, activate it */
-	if (curthread->t_vmspace) {
-		as_activate(curthread->t_vmspace);
-	}
-
-	/* Enable interrupts */
-	spl0();
-
-#if OPT_SYNCHPROBS
-	/* Yield a random number of times to get a good mix of threads */
-	{
-		int i, n;
-		n = random()%161 + random()%161;
-		for (i=0; i<n; i++) {
-			thread_yield();
-		}
-	}
-#endif
-	
-	/* Call the function */
-	func(data1, data2);
-
-	/* Done. */
-	thread_exit();
-}
+/*
+ * Core thread system.
+ */
+#include <types.h>
+#include <lib.h>
+#include <kern/errno.h>
+#include <array.h>
+#include <machine/spl.h>
+#include <machine/pcb.h>
+#include <thread.h>
+#include <synch.h>
+#include <curthread.h>
+#include <scheduler.h>
+#include <addrspace.h>
+#include <vnode.h>
+#include "opt-synchprobs.h"
+
+/* States a thread can be in. */
+typedef enum {
+	S_RUN,
+	S_READY,
+	S_SLEEP,
+	S_ZOMB,
+} threadstate_t;
+
+/*struct link_list
+{
+	struct link_list *next;
+	int pid_value;
+};*/
+
+//int pid_array[1000];
+//int arraycount;
+int pid_assign;
+
+
+
+/* Global variable for the thread currently executing at any given time. */
+struct thread *curthread;
+
+
+/* Table of sleeping threads. */
+static struct array *sleepers;
+
+/* List of dead threads to be disposed of. */
+static struct array *zombies;
+
+/* Total number of outstanding threads. Does not count zombies[]. */
+static int numthreads;
+
+/*
+ * Create a thread. This is used both to create the first thread's 
+ * thread structure and to create subsequent threads.
+ */
+//
+
+static
+struct thread *
+thread_create(const char *name)
+{
+	struct thread *thread = kmalloc(sizeof(struct thread));
+	if (thread==NULL) {
+		return NULL;
+	}
+	thread->t_name = kstrdup(name);
+	if (thread->t_name==NULL) {
+		kfree(thread);
+		return NULL;
+	}
+	thread->t_sleepaddr = NULL;
+	thread->t_stack = NULL;
+	
+	thread->t_vmspace = NULL;
+
+	thread->t_cwd = NULL;
+	
+	
+	//thread->info.status = 100; // -1 means not in use; otherwise it will be equal to the exitcode.
+	//thread-> threadlock = lock_create("threadlock");
+	thread->lk =lock_create("lock");
+	thread-> Waitonexit = cv_create("onexit");
+	thread-> Waittoexit = cv_create("toexit");
+	thread->exitcode = 100;
+	thread->status = 0;
+	thread->pid = -1;
+    thread->parent = curthread;
+    bzero(thread->child, sizeof (thread->child));
+	// If you add things to the thread structure, be sure to initialize
+	// them here.
+	//thread->pid = (int*)q_remhead(process_ids);	//initialize the process pid
+	int interrupt = splhigh();
+	
+	/*if(arraycount > 1)		//if the array still holds some pid that is available to use 
+	{
+		thread->info.pid = pid_array[arraycount]; 
+		arraycount--;
+	}
+	else
+	{
+		if( pid_assign >20)
+			return EAGAIN;
+		else{
+			thread->info.pid = pid_assign;
+			pid_assign++;
+		}
+	}*/
+	
+	thread->pid = pid_assign;
+	pid_assign++;
+	
+	
+	splx(interrupt);
+	
+	return thread;
+}
+
+/*
+ * Destroy a thread.
+ *
+ * This function cannot be called in the victim thread's own context.
+ * Freeing the stack you're actually using to run would be... inadvisable.
+ */
+static
+void
+thread_destroy(struct thread *thread)
+{
+	assert(thread != curthread);
+
+	// If you add things to the thread structure, be sure to dispose of
+	// them here or in thread_exit.
+	/*int interrupt = splhigh();			//reclaim back the pid and store into a static array
+	arraycount++;
+	pid_array[arraycount] = thread->info.pid;
+	thread->info.pid= -1;				//set the thread pid to initial value
+	//kfree(thread->pid);
+
+	splx(interrupt);*/
+
+	// These things are cleaned up in thread_exit.
+	assert(thread->t_vmspace==NULL);
+	assert(thread->t_cwd==NULL);
+	
+	if (thread->t_stack) {
+		kfree(thread->t_stack);
+	}
+
+	kfree(thread->t_name);
+    cv_destroy(thread->Waitonexit);
+    thread->Waitonexit = NULL;
+	cv_destroy(thread->Waittoexit);
+    thread->Waittoexit = NULL;
+    lock_destroy(thread->lk);
+    thread->lk = NULL;
+	kfree(thread);
+}
+
+
+/*
+ * Remove zombies. (Zombies are threads/processes that have exited but not
+ * been fully deleted yet.)
+ */
+static
+void
+exorcise(void)
+{
+	int i, result;
+
+	assert(curspl>0);
+	
+	for (i=0; i<array_getnum(zombies); i++) {
+		struct thread *z = array_getguy(zombies, i);
+		assert(z!=curthread);
+		thread_destroy(z);
+	}
+	result = array_setsize(zombies, 0);
+	/* Shrinking the array; not supposed to be able to fail. */
+	assert(result==0);
+}
+
+/*
+ * Kill all sleeping threads. This is used during panic shutdown to make 
+ * sure they don't wake up again and interfere with the panic.
+ */
+static
+void
+thread_killall(void)
+{
+	int i, result;
+
+	assert(curspl>0);
+
+	/*
+	 * Move all sleepers to the zombie list, to be sure they don't
+	 * wake up while we're shutting down.
+	 */
+
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		kprintf("sleep: Dropping thread %s\n", t->t_name);
+
+		/*
+		 * Don't do this: because these threads haven't
+		 * been through thread_exit, thread_destroy will
+		 * get upset. Just drop the threads on the floor,
+		 * which is safer anyway during panic.
+		 *
+		 * array_add(zombies, t);
+		 */
+	}
+
+	result = array_setsize(sleepers, 0);
+	/* shrinking array: not supposed to fail */
+	assert(result==0);
+}
+
+/*
+ * Shut down the other threads in the thread system when a panic occurs.
+ */
+void
+thread_panic(void)
+{
+	assert(curspl > 0);
+
+	thread_killall();
+	scheduler_killall();
+}
+
+/*
+ * Thread initialization.
+ */
+struct thread *
+thread_bootstrap(void)
+{
+	struct thread *me;
+
+	/* Create the data structures we need. */
+	sleepers = array_create();
+	if (sleepers==NULL) {
+		panic("Cannot create sleepers array\n");
+	}
+
+	zombies = array_create();
+	if (zombies==NULL) {
+		panic("Cannot create zombies array\n");
+	}
+	
+	/*
+	 * Create the thread structure for the first thread
+	 * (the one that's already running)
+	 */
+	me = thread_create("<boot/menu>");
+	if (me==NULL) {
+		panic("thread_bootstrap: Out of memory\n");
+	}
+
+	/*
+	 * Leave me->t_stack NULL. This means we're using the boot stack,
+	 * which can't be freed.
+	 */
+
+	/* Initialize the first thread's pcb */
+	md_initpcb0(&me->t_pcb);
+
+	/* Set curthread */
+	curthread = me;
+
+	/* Number of threads starts at 1 */
+	numthreads = 1;
+
+	pid_assign = 0;				//initialize the global variables
+	
+	//arraycount=0;
+	//pid_h = NULL;
+	
+	
+//	p_wait = sem_create("p_wait", 1);
+//	p_exit = sem_create("p_exit", 1);
+	
+	/* Done */
+	return me;
+}
+
+/*
+ * Thread final cleanup.
+ */
+void
+thread_shutdown(void)
+{
+	array_destroy(sleepers);
+	sleepers = NULL;
+	array_destroy(zombies);
+	zombies = NULL;
+	// Don't do this - it frees our stack and we blow up
+	
+	//thread_destroy(curthread);
+}
+
+/*
+ * Create a new thread based on an existing one.
+ * The new thread has name NAME, and starts executing in function FUNC.
+ * DATA1 and DATA2 are passed to FUNC.
+ */
+int
+thread_fork(const char *name, 
+	    void *data1, unsigned long data2,
+	    void (*func)(void *, unsigned long),
+	    struct thread **ret)
+{
+	struct thread *newguy;
+	int s, result;
+
+	/* Allocate a thread */
+	newguy = thread_create(name);
+	if (newguy==NULL) {
+		return ENOMEM;
+	}
+
+	/* Allocate a stack */
+	newguy->t_stack = kmalloc(STACK_SIZE);
+	if (newguy->t_stack==NULL) {
+		kfree(newguy->t_name);
+		kfree(newguy);
+		return ENOMEM;
+	}
+
+	/* stick a magic number on the bottom end of the stack */
+	newguy->t_stack[0] = 0xae;
+	newguy->t_stack[1] = 0x11;
+	newguy->t_stack[2] = 0xda;
+	newguy->t_stack[3] = 0x33;
+
+	/* Inherit the current directory */
+	if (curthread->t_cwd != NULL) {
+		VOP_INCREF(curthread->t_cwd);
+		newguy->t_cwd = curthread->t_cwd;
+	}
+
+	/* Set up the pcb (this arranges for func to be called) */
+	md_initpcb(&newguy->t_pcb, newguy->t_stack, data1, data2, func);
+
+	/* Interrupts off for atomicity */
+	s = splhigh();
+
+	/*
+	 * Make sure our data structures have enough space, so we won't
+	 * run out later at an inconvenient time.
+	 */
+	result = array_preallocate(sleepers, numthreads+1);
+	if (result) {
+		goto fail;
+	}
+	result = array_preallocate(zombies, numthreads+1);
+	if (result) {
+		goto fail;
+	}
+
+	/* Do the same for the scheduler. */
+	result = scheduler_preallocate(numthreads+1);
+	if (result) {
+		goto fail;
+	}
+
+	/* Make the new thread runnable */
+	result = make_runnable(newguy);
+	if (result != 0) {
+		goto fail;
+	}
+
+	/*
+	 * Increment the thread counter. This must be done atomically
+	 * with the preallocate calls; otherwise the count can be
+	 * temporarily too low, which would obviate its reason for
+	 * existence.
+	 */
+	numthreads++;
+	
+	newguy->parent = curthread;
+	int i =0;
+	for(i =0;i<20;i++)
+	{
+		if(curthread->child[i]==NULL)
+			{
+				curthread->child[i]=newguy;
+				break;
+			}
+		
+	}
+	
+
+	/* Done with stuff that needs to be atomic */
+	splx(s);
+
+	/*
+	 * Return new thread structure if it's wanted.  Note that
+	 * using the thread structure from the parent thread should be
+	 * done only with caution, because in general the child thread
+	 * might exit at any time.
+	 */
+	if (ret != NULL) {
+		*ret = newguy;
+	}
+
+	return 0;
+
+ fail:
+	splx(s);
+	if (newguy->t_cwd != NULL) {
+		VOP_DECREF(newguy->t_cwd);
+	}
+	kfree(newguy->t_stack);
+	kfree(newguy->t_name);
+	kfree(newguy);
+
+	return result;
+}
+
+/*
+ * High level, machine-independent context switch code.
+ */
+static
+void
+mi_switch(threadstate_t nextstate)
+{
+	struct thread *cur, *next;
+	int result;
+	
+	/* Interrupts should already be off. */
+	assert(curspl>0);
+
+	if (curthread != NULL && curthread->t_stack != NULL) {
+		/*
+		 * Check the magic number we put on the bottom end of
+		 * the stack in thread_fork. If these assertions go
+		 * off, it most likely means you overflowed your stack
+		 * at some point, which can cause all kinds of
+		 * mysterious other things to happen.
+		 */
+		assert(curthread->t_stack[0] == (char)0xae);
+		assert(curthread->t_stack[1] == (char)0x11);
+		assert(curthread->t_stack[2] == (char)0xda);
+		assert(curthread->t_stack[3] == (char)0x33);
+	}
+	
+	/* 
+	 * We set curthread to NULL while the scheduler is running, to
+	 * make sure we don't call it recursively (this could happen
+	 * otherwise, if we get a timer interrupt in the idle loop.)
+	 */
+	if (curthread == NULL) {
+		return;
+	}
+	cur = curthread;
+	curthread = NULL;
+
+	/*
+	 * Stash the current thread on whatever list it's supposed to go on.
+	 * Because we preallocate during thread_fork, this should not fail.
+	 */
+
+	if (nextstate==S_READY) {
+		result = make_runnable(cur);
+	}
+	else if (nextstate==S_SLEEP) {
+		/*
+		 * Because we preallocate sleepers[] during thread_fork,
+		 * this should never fail.
+		 */
+		result = array_add(sleepers, cur);
+	}
+	else {
+		assert(nextstate==S_ZOMB);
+		result = array_add(zombies, cur);
+	}
+	assert(result==0);
+
+	/*
+	 * Call the scheduler (must come *after* the array_adds)
+	 */
+
+	next = scheduler();
+
+	/* update curthread */
+	curthread = next;
+	
+	/* 
+	 * Call the machine-dependent code that actually does the
+	 * context switch.
+	 */
+	md_switch(&cur->t_pcb, &next->t_pcb);
+	
+	/*
+	 * If we switch to a new thread, we don't come here, so anything
+	 * done here must be in mi_threadstart() as well, or be skippable,
+	 * or not apply to new threads.
+	 *
+	 * exorcise is skippable; as_activate is done in mi_threadstart.
+	 */
+
+	exorcise();
+
+	if (curthread->t_vmspace) {
+		as_activate(curthread->t_vmspace);
+	}
+}
+
+/*
+ * Cause the current thread to exit.
+ *
+ * We clean up the parts of the thread structure we don't actually
+ * need to run right away. The rest has to wait until thread_destroy
+ * gets called from exorcise().
+ */
+void
+thread_exit(void)
+{
+	
+	
+	
+	
+	if (curthread->t_stack != NULL) {
+		/*
+		 * Check the magic number we put on the bottom end of
+		 * the stack in thread_fork. If these assertions go
+		 * off, it most likely means you overflowed your stack
+		 * at some point, which can cause all kinds of
+		 * mysterious other things to happen.
+		 */
+		assert(curthread->t_stack[0] == (char)0xae);
+		assert(curthread->t_stack[1] == (char)0x11);
+		assert(curthread->t_stack[2] == (char)0xda);
+		assert(curthread->t_stack[3] == (char)0x33);
+	}
+
+	splhigh();
+	
+	
+
+	if (curthread->t_vmspace) {
+		/*
+		 * Do this carefully to avoid race condition with
+		 * context switch code.
+		 */
+		struct addrspace *as = curthread->t_vmspace;
+		curthread->t_vmspace = NULL;
+		as_destroy(as);
+	}
+
+	if (curthread->t_cwd) {
+		VOP_DECREF(curthread->t_cwd);
+		curthread->t_cwd = NULL;
+	}
+
+	assert(numthreads>0);
+	numthreads--;
+	mi_switch(S_ZOMB);
+
+	panic("Thread came back from the dead!\n");
+}
+
+/*
+ * Yield the cpu to another process, but stay runnable.
+ */
+void
+thread_yield(void)
+{
+	int spl = splhigh();
+
+	/* Check sleepers just in case we get here after shutdown */
+	assert(sleepers != NULL);
+
+	mi_switch(S_READY);
+	splx(spl);
+}
+
+/*
+ * Yield the cpu to another process, and go to sleep, on "sleep
+ * address" ADDR. Subsequent calls to thread_wakeup with the same
+ * value of ADDR will make the thread runnable again. The address is
+ * not interpreted. Typically it's the address of a synchronization
+ * primitive or data structure.
+ *
+ * Note that (1) interrupts must be off (if they aren't, you can
+ * end up sleeping forever), and (2) you cannot sleep in an 
+ * interrupt handler.
+ */
+void
+thread_sleep(const void *addr)
+{
+	// may not sleep in an interrupt handler
+	assert(in_interrupt==0);
+	
+	curthread->t_sleepaddr = addr;
+	mi_switch(S_SLEEP);
+	curthread->t_sleepaddr = NULL;
+}
+
+/*
+ * Wake up one or more threads who are sleeping on "sleep address"
+ * ADDR.
+ */
+void
+thread_wakeup(const void *addr)
+{
+	int i, result;
+	
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	// This is inefficient. Feel free to improve it.
+	
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		if (t->t_sleepaddr == addr) {
+			
+			// Remove from list
+			array_remove(sleepers, i);
+			
+			// must look at the same sleepers[i] again
+			i--;
+
+			/*
+			 * Because we preallocate during thread_fork,
+			 * this should never fail.
+			 */
+			result = make_runnable(t);
+			assert(result==0);
+						//BREAK THE LOOP, MAKE IT WAKE UP ONLY ONE GUY AT ONCE
+		}
+	}
+}
+
+void
+thread_wakeone(const void *addr)
+{
+	int i, result;
+	
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	// This is inefficient. Feel free to improve it.
+	
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		if (t->t_sleepaddr == addr) {
+			
+			// Remove from list
+			array_remove(sleepers, i);
+			
+			// must look at the same sleepers[i] again
+			i--;
+
+			/*
+			 * Because we preallocate during thread_fork,
+			 * this should never fail.
+			 */
+			result = make_runnable(t);
+			assert(result==0);
+			break;		//BREAK THE LOOP, MAKE IT WAKE UP ONLY ONE GUY AT ONCE
+		}
+	}
+}
+
+/*
+ * Return nonzero if there are any threads who are sleeping on "sleep address"
+ * ADDR. This is meant to be used only for diagnostic purposes.
+ */
+int
+thread_hassleepers(const void *addr)
+{
+	int i;
+	
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		if (t->t_sleepaddr == addr) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * New threads actually come through here on the way to the function
+ * they're supposed to start in. This is so when that function exits,
+ * thread_exit() can be called automatically.
+ */
+void
+mi_threadstart(void *data1, unsigned long data2, 
+	       void (*func)(void *, unsigned long))
+{
+	/* If we have an address space, activate it */
+	if (curthread->t_vmspace) {
+		as_activate(curthread->t_vmspace);
+	}
+
+	/* Enable interrupts */
+	spl0();
+
+#if OPT_SYNCHPROBS
+	/* Yield a random number of times to get a good mix of threads */
+	{
+		int i, n;
+		n = random()%161 + random()%161;
+		for (i=0; i<n; i++) {
+			thread_yield();
+		}
+	}
+#endif
+	
+	/* Call the function */
+	func(data1, data2);
+
+	/* Done. */
+	thread_exit();
+}
Index: kern/arch/mips/mips/syscall.c
===================================================================
--- kern/arch/mips/mips/syscall.c	(revision 20)
+++ kern/arch/mips/mips/syscall.c	(working copy)
@@ -1,341 +1,323 @@
-#include <types.h>
-#include <kern/errno.h>
-#include <lib.h>
-#include <machine/pcb.h>
-#include <machine/spl.h>
-#include <machine/trapframe.h>
-#include <kern/callno.h>
-#include <syscall.h>
-#include <thread.h>
-#include <curthread.h>
-#include <synch.h>
-#include <sysio.h>
-//#include </../lib/copyinout.c>
-//#include <sys_execv.h>
-/*
- * System call handler.
- *
- * A pointer to the trapframe created during exception entry (in
- * exception.S) is passed in.
- *
- * The calling conventions for syscalls are as follows: Like ordinary
- * function calls, the first 4 32-bit arguments are passed in the 4
- * argument registers a0-a3. In addition, the system call number is
- * passed in the v0 register.
- *
- * On successful return, the return value is passed back in the v0
- * register, like an ordinary function call, and the a3 register is
- * also set to 0 to indicate success.
- *
- * On an error return, the error code is passed back in the v0
- * register, and the a3 register is set to 1 to indicate failure.
- * (Userlevel code takes care of storing the error code in errno and
- * returning the value -1 from the actual userlevel syscall function.
- * See src/lib/libc/syscalls.S and related files.)
- *
- * Upon syscall return the program counter stored in the trapframe
- * must be incremented by one instruction; otherwise the exception
- * return code will restart the "syscall" instruction and the system
- * call will repeat forever.
- *
- * Since none of the OS/161 system calls have more than 4 arguments,
- * there should be no need to fetch additional arguments from the
- * user-level stack.
- *
- * Watch out: if you make system calls that have 64-bit quantities as
- * arguments, they will get passed in pairs of registers, and not
- * necessarily in the way you expect. We recommend you don't do it.
- * (In fact, we recommend you don't use 64-bit quantities at all. See
- * arch/mips/include/types.h.)
- */
-
-//struct lock*lock;
-int sys_getpid()
-{
-	
-/**/	int pid = (curthread->pid);
-	return pid;
-}
-
-
-
-int
-sys_waitpid(int a0,int *a1, int a2, int *returnval)
-{
-	int pid = a0;
-	if(a2 != 0)	// if the option is not valid.
-		return EINVAL;
-	if(a1 == NULL)	// if the status is not a valid pointer.
-		return EFAULT;
-	
-	struct thread *temp;
-	lock_acquire(curthread->lk);
-	int i =0;
-	for(i=0;i<20;i++){
-		lock_acquire(curthread->child[i]->lk);
-		temp = curthread->child[i];					//acquire child lock to do operation
-		if( curthread->child[i]->pid == pid)
-		{
-			if(curthread->child[i]->status == 0)			//child is still running
-			{
-				if(curthread->child[i]->waiting_parent == 1){	//child has been waiting
-					cv_signal(curthread->child[i]->Waittoexit, curthread->child[i]->lk);
-					*(int *)(a1) = curthread->child[i]->exitcode;
-					cv_wait(curthread->child[i]->Waitonexit, curthread->child[i]->lk);//wait child to signal you, indicate that he finished
-				}
-				else{	// child is not waiting. just wait for child now.
-					curthread->waiting_child = 1;
-					
-					cv_wait(curthread->child[i]->Waitonexit, curthread->child[i]->lk);//wait child to signal you, indicate that he finished
-					*(int *)(a1) = curthread->child[i]->exitcode;
-					cv_signal(curthread->child[i]->Waittoexit,curthread->child[i]->lk);//signal child to indicate that get the exitcode
-				}
-			}
-		    	curthread->child[i] = NULL;
-		    	
-		    	break;	
-		}
-        	lock_release(curthread->child[i]->lk);
-	}
-	//kprintf("in here!!!");
-	lock_release(curthread->lk);
-	//lock_release(temp->lk);		
-	*returnval = pid;
-	return 0;
-	
-}
-
-
-
-void
-sys__exit(int exitcode) {
-	
-	lock_acquire(curthread->lk);
-	//now check children
-	int i =0;
-	curthread->waiting_child = 2;
-	for(i = 0; i < 20; i++)		//check for child
-	{
-        	if (curthread->child[i] == NULL) // if no child in this element
-        		continue;
-        		
-		lock_acquire(curthread->child[i]->lk);			//PROBLEMS ARE HERE!!!
-		//kprintf("Exittingchild pid is %d,self %d, parent %d\n", curthread->child[i]->pid,curthread->pid, curthread->parent->pid);
-		if( curthread->child[i]->status == 1){
-			// child exited already
-			;
-			//cv_signal(curthread->child[i]->Waittoexit, curthread->child[i]->lk);
-		}
-		else{	// child status == 0, child didnt exit
-			curthread->child[i]->parent=NULL;
-		}
-		lock_release(curthread->child[i]->lk);
-	
-	}
-	
-	//NOW check parent
-	if(curthread->parent != NULL)
-	{//kprintf("Exitting pid is %d,Child pid is %d\n", curthread-> pid,curthread->parent->pid);	//PARENT STILL RUNNING
-		curthread->exitcode = exitcode;
-		curthread->status = 1;
-		
-		if(curthread->parent->waiting_child == 0){//if parent is not waiting, or parent didnt exit yet
-			curthread->waiting_parent = 1;
-			cv_wait(curthread->Waittoexit, curthread->lk);
-			cv_signal(curthread->Waitonexit, curthread->lk);
-			assert(lock_do_i_hold(curthread->lk) == 1);	
-			//cv_wait(curthread->Waittoexit, curthread->lk);	
-		}
-		else if(curthread->parent->waiting_child == 1){// if parent is waiting, or parent didnt exit yet
-			cv_signal(curthread->Waitonexit, curthread->lk);
-			assert(lock_do_i_hold(curthread->lk) == 1);
-			cv_wait(curthread->Waittoexit, curthread->lk);		//child will be locked by parent in waitpid()
-		}
-	}
-	lock_release(curthread->lk);	
-	thread_exit();	
-}
-
-int sys_fork(struct trapframe *tf, int * returnval) //fork a new thread
-{
-	
-	int err;
-	/*if(numthreads>=20)
-		return EAGAIN ;			//limit the thread number to 20*/
-		
-	struct thread * childthread ;			//create a child thread
-	struct trapframe *copy = kmalloc(sizeof(struct trapframe)) ;	//create trapframe for later to move to the new one
-	struct addrspace *newspace ;	//allocate new address space for the process
-	
-	
-	if (copy == NULL) {		//the heap is full?
-		err = ENOMEM;
-		return err;
-	}
-	
-	memcpy(copy,tf,sizeof(struct trapframe)); //let the new trapframe pointer points on the old tf ,this put the old tf on heap, deep copy
-	//
-/**/	int i = as_copy(curthread->t_vmspace,&newspace);
-	
-	if(i!=0)			//if no memory
-		goto fail2;
-		//kprintf("returned here?\n");
-	as_activate(curthread->t_vmspace);
-	
-	//kprintf("now start to create child\n");
-/**/	*returnval = thread_fork(curthread->t_name, copy, (unsigned long)newspace, md_forkentry, &childthread);
-
-	if(*returnval!=0){
-		//kprintf("get in here?\n");
-		err = ENOMEM;
-		tf->tf_a3 = 1;		//indicates a fail operation
-		tf->tf_v0 =err;
-		goto fail2;
-	}
-	
-	(*returnval) = childthread->pid;
-    for (i = 0; i < 20; i ++) {
-        if (curthread->child[i] == NULL) {
-            curthread->child[i] = childthread;
-            break;
-        }
-    }
-    assert(i<20);
-	return 0;
-	
-fail2:	kfree(copy);
-fail1:	return err;
-}
-
-void
-md_forkentry(struct trapframe *tf, unsigned long data)			//this function is to actually store into child pro
-{
-	/*
-	 * This function is provided as a reminder. You need to write
-	 * both it and the code that calls it.
-	 *
-	 * Thus, you can trash it and do things another way if you prefer.
-	 */
-	struct trapframe *local ,temp;
-	struct addrspace *childspace;
-	
-	childspace = (struct addrspace*) data;     //the same space as parent by casting
-	//memcpy(local,tf,sizeof(struct trapframe));
-	temp = *tf;
-	local = &temp;
-	
-	int i =	as_copy(childspace, &curthread->t_vmspace);
-	//as_destroy(childspace);
-	if(i!=0)
-		return;
-
-	as_activate(curthread->t_vmspace);
-	kfree(tf);
-	local->tf_epc += 4;			//increment PC
-	local->tf_v0 = 0;
-	local->tf_a3 = 0; 			//succeed , no failure 
-
-	assert(curthread->t_vmspace!=NULL);
-	mips_usermode(local);			//wrap to user space
-	
-	
-	(void)tf;
-}
-
-
-void
-mips_syscall(struct trapframe *tf)
-{
-	int callno;
-	int32_t retval;
-	int err;
-
-	
-	assert(curspl==0);
-
-	callno = tf->tf_v0;
-	int a2;
-	
-	
-	//lock =lock_create("lock");
-	/*
-	 * Initialize retval to 0. Many of the system calls don't
-	 * really return a value, just 0 for success and -1 on
-	 * error. Since retval is the value returned on success,
-	 * initialize it to 0 by default; thus it's not necessary to
-	 * deal with it except for calls that return other values, 
-	 * like write.
-	 */
-
-	retval = 0;
-
-	switch (callno) {
-	    case SYS_reboot:
-		err = sys_reboot(tf->tf_a0);
-		break;
-
-	    /* Add stuff here */
-	    //    NEED TO ADD SYS_getpid, SYS__exit, SYS_fork, SYS_waitpid, SYS_execv
- 	    case SYS__exit:
- 	    	sys__exit(tf->tf_a0);
- 	    	break;
- 	    	
- 	 /*  case SYS_execv:
- 	    	err = sys_execv(name, arg[]);
- 	    	break;*/
- 	    	
- 	    case SYS_fork:
- 	    	err = sys_fork(tf,&retval);
- 	    	break;
- 	    	
- 	   case SYS_waitpid:
- 	    	err = sys_waitpid(tf->tf_a0, tf->tf_a1,tf->tf_a2,&retval);
- 	    	break;
- 	    	
- 	    case SYS_getpid:
- 	    	err = sys_getpid();
- 	    	break;
- 	    
- 	    case SYS_write:
- 	    	err = sys_write(tf->tf_a0,tf->tf_a1,tf->tf_a2);
- 	    	break;
- 	    
- 	    case SYS_read:
- 	    	err = sys_read(tf->tf_a0,tf->tf_a1,tf->tf_a2,&retval);
- 	   
- 	    	break;
- 	    	
-	    default:
-		kprintf("Unknown syscall %d\n", callno);
-		err = ENOSYS;
-		break;
-	}
-
-
-	if (err) {
-		/*
-		 * Return the error code. This gets converted at
-		 * userlevel to a return value of -1 and the error
-		 * code in errno.
-		 */
-		tf->tf_v0 = err;
-		tf->tf_a3 = 1;      /* signal an error */
-	}
-	else {
-		/* Success. */
-		tf->tf_v0 = retval;
-		tf->tf_a3 = 0;      /* signal no error */
-	}
-	
-	/*
-	 * Now, advance the program counter, to avoid restarting
-	 * the syscall over and over again.
-	 */
-	
-	tf->tf_epc += 4;
-
-	/* Make sure the syscall code didn't forget to lower spl */
-	assert(curspl==0);
-}
-
-
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <machine/pcb.h>
+#include <machine/spl.h>
+#include <machine/trapframe.h>
+#include <kern/callno.h>
+#include <syscall.h>
+#include <thread.h>
+#include <curthread.h>
+#include <synch.h>
+#include <sysio.h>
+//#include <sys_execv.h>
+/*
+ * System call handler.
+ *
+ * A pointer to the trapframe created during exception entry (in
+ * exception.S) is passed in.
+ *
+ * The calling conventions for syscalls are as follows: Like ordinary
+ * function calls, the first 4 32-bit arguments are passed in the 4
+ * argument registers a0-a3. In addition, the system call number is
+ * passed in the v0 register.
+ *
+ * On successful return, the return value is passed back in the v0
+ * register, like an ordinary function call, and the a3 register is
+ * also set to 0 to indicate success.
+ *
+ * On an error return, the error code is passed back in the v0
+ * register, and the a3 register is set to 1 to indicate failure.
+ * (Userlevel code takes care of storing the error code in errno and
+ * returning the value -1 from the actual userlevel syscall function.
+ * See src/lib/libc/syscalls.S and related files.)
+ *
+ * Upon syscall return the program counter stored in the trapframe
+ * must be incremented by one instruction; otherwise the exception
+ * return code will restart the "syscall" instruction and the system
+ * call will repeat forever.
+ *
+ * Since none of the OS/161 system calls have more than 4 arguments,
+ * there should be no need to fetch additional arguments from the
+ * user-level stack.
+ *
+ * Watch out: if you make system calls that have 64-bit quantities as
+ * arguments, they will get passed in pairs of registers, and not
+ * necessarily in the way you expect. We recommend you don't do it.
+ * (In fact, we recommend you don't use 64-bit quantities at all. See
+ * arch/mips/include/types.h.)
+ */
+
+//struct lock*lock;
+int sys_getpid()
+{
+	lock_acquire(curthread->lk);
+/**/	int pid = (curthread->pid);
+    lock_release(curthread->lk);
+	return pid;
+}
+
+
+
+int
+sys_waitpid(struct trapframe *tf, int *returnval)
+{
+	int pid = tf->tf_a0;
+	if(tf->tf_a2 != 0)	// if the option is not valid.
+		return EINVAL;
+	if(tf->tf_a1 == NULL)	// if the status is not a valid pointer.
+		return EFAULT;
+		
+	lock_acquire(curthread->lk);
+	
+	int i =0;
+	for(i=0;i<20;i++){
+		lock_acquire(curthread->child[i]->lk);					//acquire child lock to do operation
+		if( curthread->child[i]->pid == pid)
+		{
+			if(curthread->child[i]->status == 0)			//child is still running
+			{
+				cv_wait(curthread->child[i]->Waitonexit, curthread->child[i]->lk);			//wait child to signal you, indicate that he finished
+			}
+            assert(curthread->child[i]->status == -1);
+            tf->tf_a1 = curthread->child[i]->exitcode;		//child is not running
+            cv_signal(curthread->child[i]->Waittoexit,curthread->child[i]->lk);	//signal child to indicate that get the exitcode
+            lock_release(curthread->child[i]->lk);
+            curthread->child[i] = NULL;
+            break;	
+		}
+        lock_release(curthread->child[i]->lk);
+	}
+	
+	lock_release(curthread->lk);
+			
+	*returnval = pid;
+	return 0;
+	
+}
+
+
+
+void
+sys__exit(int exitcode) {
+	
+	lock_acquire(curthread->lk);
+	//now check children
+	int i =0;
+	for(i = 0; i<20; i++)		//check for child
+	{
+        if (curthread->child[i] == NULL) continue;
+		lock_acquire(curthread->child[i]->lk);
+		
+		if( curthread->child[i]->status != 0){
+			// child exited already
+			cv_signal(curthread->child[i]->Waittoexit, curthread->child[i]->lk);
+		}
+		else{
+			curthread->child[i]->parent=NULL;
+		}
+		lock_release(curthread->child[i]->lk);
+	
+	}
+	
+	//NOW check parent
+	if(curthread->parent != NULL)
+	{						//PARENT STILL RUNNING
+		curthread->exitcode = exitcode;
+		curthread->status = -1;
+		cv_signal(curthread->Waitonexit, curthread->lk);
+		cv_wait(curthread->Waittoexit, curthread->lk);		//child will be locked by parent in waitpid()
+	}
+		
+	lock_release(curthread->lk);	
+	thread_exit();	
+}
+
+int sys_fork(struct trapframe *tf, int * returnval) //fork a new thread
+{
+	
+	int err;
+	/*if(numthreads>=20)
+		return EAGAIN ;			//limit the thread number to 20*/
+		
+	struct thread * childthread ;			//create a child thread
+	struct trapframe *copy = kmalloc(sizeof(struct trapframe)) ;	//create trapframe for later to move to the new one
+	struct addrspace *newspace ;	//allocate new address space for the process
+	
+	
+	if (copy == NULL) {		//the heap is full?
+		err = ENOMEM;
+		goto fail1;
+	}
+	
+	memcpy(copy,tf,sizeof(struct trapframe)); //let the new trapframe pointer points on the old tf ,this put the old tf on heap, deep copy
+	//
+/**/	int i = as_copy(curthread->t_vmspace,&newspace);
+	
+	if(i!=0)			//if no memory
+		goto fail2;
+		//kprintf("returned here?\n");
+	// as_activate(curthread->t_vmspace);
+	int spl = splhigh();
+	//kprintf("now start to create child\n");
+/**/	*returnval = thread_fork(curthread->t_name, 
+                        copy, (unsigned long)newspace, md_forkentry, &childthread);
+
+	if(*returnval!=0){
+		//kprintf("get in here?\n");
+        assert("no memory");
+		err = ENOMEM;
+		tf->tf_a3 = 1;		//indicates a fail operation
+		tf->tf_v0 =err;
+        splx(spl);
+		goto fail2;
+	}
+	childthread->parent = curthread;
+	// (*returnval) = childthread->pid;
+   	splx(spl);
+    
+    // for (i = 0; i < 20; i ++) {
+        // if (curthread->child[i] == NULL) {
+            // curthread->child[i] = childthread;
+            // break;
+        // }
+    // }
+    assert(i<20);
+	return 0;
+	
+fail2:	kfree(copy);
+fail1:	return err;
+}
+
+void
+md_forkentry(struct trapframe *tf, unsigned long data)			//this function is to actually store into child pro
+{
+	/*
+	 * This function is provided as a reminder. You need to write
+	 * both it and the code that calls it.
+	 *
+	 * Thus, you can trash it and do things another way if you prefer.
+	 */
+	struct trapframe temp;
+	struct addrspace *childspace;
+	
+	curthread->t_vmspace = (struct addrspace*) data;     //the same space as parent by casting
+	//memcpy(local,tf,sizeof(struct trapframe));
+    memmove(&temp, tf, sizeof(struct trapframe));
+	// temp = *tf;
+	// local = &temp;
+	
+	// int i =	as_copy(childspace, &curthread->t_vmspace);
+
+	// as_destroy(childspace);
+	// if(i!=0)
+		// return;
+
+	as_activate(curthread->t_vmspace);
+	kfree(tf);
+    temp.tf_epc += 4;			//increment PC
+	temp.tf_v0 = 0;
+	temp.tf_a3 = 0; 			//succeed , no failure 
+
+	assert(curthread->t_vmspace!=NULL);
+	mips_usermode(&temp);			//wrap to user space
+	
+	
+	(void)tf;
+}
+
+
+void
+mips_syscall(struct trapframe *tf)
+{
+	int callno;
+	int32_t retval;
+	int err;
+
+	
+	assert(curspl==0);
+
+	callno = tf->tf_v0;
+	
+	
+	//lock =lock_create("lock");
+	/*
+	 * Initialize retval to 0. Many of the system calls don't
+	 * really return a value, just 0 for success and -1 on
+	 * error. Since retval is the value returned on success,
+	 * initialize it to 0 by default; thus it's not necessary to
+	 * deal with it except for calls that return other values, 
+	 * like write.
+	 */
+
+	retval = 0;
+
+	switch (callno) {
+	    case SYS_reboot:
+		err = sys_reboot(tf->tf_a0);
+		break;
+
+	    /* Add stuff here */
+	    //    NEED TO ADD SYS_getpid, SYS__exit, SYS_fork, SYS_waitpid, SYS_execv
+ 	    case SYS__exit:
+ 	    	sys__exit(tf->tf_a0);
+ 	    	break;
+ 	    	
+ 	 /*  case SYS_execv:
+ 	    	err = sys_execv(name, arg[]);
+ 	    	break;*/
+ 	    	
+ 	    case SYS_fork:
+ 	    	err = sys_fork(tf,&retval);
+ 	    	break;
+ 	    	
+ 	   case SYS_waitpid:
+ 	    	err = sys_waitpid(tf, &retval);
+ 	    	break;
+ 	    	
+ 	    case SYS_getpid:
+ 	    	err = sys_getpid();
+ 	    	break;
+ 	    
+ 	    case SYS_write:
+ 	    	err = sys_write(tf->tf_a0,tf->tf_a1,tf->tf_a2);
+ 	    	break;
+ 	    
+ 	    case SYS_read:
+ 	    	err = sys_read(tf->tf_a0,tf->tf_a1,tf->tf_a2, &retval);
+ 	    	break;
+ 	    	
+	    default:
+		kprintf("Unknown syscall %d\n", callno);
+		err = ENOSYS;
+		break;
+	}
+
+
+	if (err) {
+		/*
+		 * Return the error code. This gets converted at
+		 * userlevel to a return value of -1 and the error
+		 * code in errno.
+		 */
+		tf->tf_v0 = err;
+		tf->tf_a3 = 1;      /* signal an error */
+	}
+	else {
+		/* Success. */
+		tf->tf_v0 = retval;
+		tf->tf_a3 = 0;      /* signal no error */
+	}
+	
+	/*
+	 * Now, advance the program counter, to avoid restarting
+	 * the syscall over and over again.
+	 */
+	
+	tf->tf_epc += 4;
+
+	/* Make sure the syscall code didn't forget to lower spl */
+	assert(curspl==0);
+}
+
+
